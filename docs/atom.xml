<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Evie&#39;s Blog</title>
    <link href="https://eevie.ro/atom.xml" rel="self" type="application/rss+xml" />
  <updated>2024-04-17T14:04:SZ</updated>
  <author>
      <name>Evie Ciobanu</name>
  </author>
  <id>https://eevie.ro/</id>

  <entry>
      <title>Classical Logic in Haskell</title>
      <link href="https://eevie.ro/posts/2018-12-14-clasical-logic-in-haskell.html"/>
      <id>https://eevie.roposts/2018-12-14-clasical-logic-in-haskell.html</id>
      <updated>2018-12-14T00:00:SZ</updated>
      <category term="theory"/>
      <category term="logic"/>
      <category term="haskell"/>
      <summary>Because why not</summary>
      <content type="html"><![CDATA[<p>During a very pleasant conversation at a recent <a
href="http://bucharestfp.ro">Bucharest FP</a> meetup, <a
href="https://twitter.com/igstan">somebody</a> mentioned that
<code>Cont</code> is, almost exactly, <a
href="https://en.wikipedia.org/wiki/Peirce%27s_law"><em>Peirce's
law</em></a>. I remembered seeing a <a
href="https://twitter.com/paf31/status/1040304689932165120">tweet</a>
from Phil Freeman which proves that they are indeed equivalent. I
thought it would be a fun exercise to prove other equivalences from
classical logic.</p>
<p>This post assumes you are familar with: - the <a
href="https://www.youtube.com/watch?v=aeRVdYN6fE8">Curry-Howard
correspondence</a>, - classical and intuitionistic logic (for example,
see it explained using Coq in <a
href="https://softwarefoundations.cis.upenn.edu/current/lf-current/Logic.html">Software
Foundations</a>), and - one of Haskell, Agda, Idris or Coq.</p>
<h1 id="monadcont-and-the-law-of-excluded-middle">MonadCont and the Law
of Excluded Middle</h1>
<p>Haskell and PureScript define <code>MonadCont</code>, which represent
monads that support the <em>call-with-current-continuation</em>
(<code>callCC</code>) operation:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">MonadCont</span> m <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    callCC ::</span> ((a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m a) <span class="ot">-&gt;</span> m a </span></code></pre></div>
<p><code>callCC</code> generally calls the function it receives, passing
it the current continuation (the <code>a -&gt; m b</code>). This acts
like an <code>abort</code> method, or an early exit.</p>
<p>The interesting part is that this monad looks very similar to
<em>Peirce's law</em>:</p>
<p>$ ((P \to Q) \to P) \to P $</p>
<p>If we replace <code>P</code> with <code>a</code> (or
<code>m a</code>) and <code>Q</code> with <code>m b</code>, we get the
exact same thing. Since we are dealing with monads, we need to use
Kleisli arrows, so all implications from logic must be lifted as such
(so <code>P -&gt; Q</code> becomes <code>a -&gt; m b</code>).</p>
<h2 id="proving-equivalences">Proving equivalences</h2>
<p>In order to keep things clean, I decided to wrap each equivalent law
in its own newtype and write an instance of <code>Iso</code> (which
translates to iff) between each of the laws and the <em>law of excluded
middle</em>.</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE InstanceSigs          #-}</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE RankNTypes            #-}</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ScopedTypeVariables   #-}</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Logic</span> <span class="kw">where</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Control.Applicative</span> (liftA2)</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Control.Monad</span>       ((&lt;=&lt;))</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Data.Void</span>           (<span class="dt">Void</span>, absurd)</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Iso</span> a b <span class="kw">where</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="ot">    to ::</span> a <span class="ot">-&gt;</span> b</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a><span class="ot">    from ::</span> b <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>This is just a neat way of having to prove both implications in an
iff, packed as <code>to</code> and <code>from</code>. Moving on, we can
declare the following types:</p>
<h3 id="peirces-law">Peirce's law</h3>
<p>Starting with the formula from logic, we can easily write out the
Haskell type by just keeping in mind we have to transform all
implications to Kleisli arrows:</p>
<p>$ \forall P, Q. ((P \to Q) \to P) \to P $</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Peirce</span> m <span class="ot">=</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Peirce</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        (  <span class="kw">forall</span> a b</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>  ((a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m a)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>        <span class="ot">-&gt;</span> m a</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>        )</span></code></pre></div>
<h3 id="law-of-excluded-middle">Law of Excluded Middle</h3>
<p>The key part to remember here is that negation in classical logic
translates to <code>-&gt; Void</code> in intuitionistic logic (and
<code>-&gt; m Void</code> in our case, since we are using Kleisli
arrows):</p>
<p>$ \forall P. P \lor \neg P $</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Lem</span> m <span class="ot">=</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Lem</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>        (  <span class="kw">forall</span> a</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>  m (<span class="dt">Either</span> a (a <span class="ot">-&gt;</span> m <span class="dt">Void</span>))</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>        )</span></code></pre></div>
<h3 id="double-negation">Double Negation</h3>
<p>Nothing new here, just rewriting negation as
<code>-&gt; m Void</code>:</p>
<p>$ \forall P. \neg \neg P \to P $</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">DoubleNegation</span> m <span class="ot">=</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">DoubleNegation</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>        (  <span class="kw">forall</span> a</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>  ((a <span class="ot">-&gt;</span> m <span class="dt">Void</span>) <span class="ot">-&gt;</span> m <span class="dt">Void</span>)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>        <span class="ot">-&gt;</span> m a</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>        )</span></code></pre></div>
<h3 id="de-morgans-law">De Morgan's Law</h3>
<p>The only new thing here is that we translate <code>and</code> to
tuples, and <code>or</code> to Either:</p>
<p>$ \forall P, Q. \neg (\neg P \land \neg Q) \to P \lor Q $</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">DeMorgan</span> m <span class="ot">=</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">DeMorgan</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>        (  <span class="kw">forall</span> a b</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>  ((a <span class="ot">-&gt;</span> m <span class="dt">Void</span>, b <span class="ot">-&gt;</span> m <span class="dt">Void</span>) <span class="ot">-&gt;</span> m <span class="dt">Void</span>)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>        <span class="ot">-&gt;</span> m (<span class="dt">Either</span> a b)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>        )</span></code></pre></div>
<h3 id="implication-to-disjunction">Implication to Disjunction</h3>
<p>$ \forall P, Q. (P \to Q) \to Q \lor \neg P $</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">ImpliesToOr</span> m <span class="ot">=</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">ImpliesToOr</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>        (  <span class="kw">forall</span> a b</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>  (a <span class="ot">-&gt;</span> m b)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>        <span class="ot">-&gt;</span> m (<span class="dt">Either</span> b (a <span class="ot">-&gt;</span> m <span class="dt">Void</span>))</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        )</span></code></pre></div>
<h2 id="proofs">Proofs</h2>
<p>If this is interesting to you, this would be a good place to look
away and try for yourself. If you do, keep in mind that typed holes are
a very useful tool in this process (see <a
href="https://wiki.haskell.org/GHC/Typed_holes">this</a> for an
example).</p>
<h3 id="lem-and-peirce">Lem and Peirce</h3>
<div class="sourceCode" id="cb8"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Iso</span> (<span class="dt">Lem</span> m) (<span class="dt">Peirce</span> m) <span class="kw">where</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    to ::</span> <span class="dt">Lem</span> m <span class="ot">-&gt;</span> <span class="dt">Peirce</span> m</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    to (<span class="dt">Lem</span> lem) <span class="ot">=</span> <span class="dt">Peirce</span> proof</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>      <span class="kw">where</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>        proof</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="ot">            ::</span> ((a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m a)</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>            <span class="ot">-&gt;</span> m a</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>        proof abort <span class="ot">=</span> lem <span class="op">&gt;&gt;=</span> <span class="fu">either</span> <span class="fu">pure</span> (go abort)</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>        go</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span class="ot">            ::</span> ((a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m a)</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>            <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m <span class="dt">Void</span>)</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>            <span class="ot">-&gt;</span> m a</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>        go abort not_a <span class="ot">=</span> abort <span class="op">$</span> <span class="fu">fmap</span> absurd <span class="op">.</span> not_a</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a><span class="ot">    from ::</span> <span class="dt">Peirce</span> m <span class="ot">-&gt;</span> <span class="dt">Lem</span> m</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>    from (<span class="dt">Peirce</span> p) <span class="ot">=</span> <span class="dt">Lem</span> <span class="op">$</span> p go</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>      <span class="kw">where</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>        go</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a><span class="ot">            ::</span> (<span class="dt">Either</span> a (a <span class="ot">-&gt;</span> m <span class="dt">Void</span>) <span class="ot">-&gt;</span> m <span class="dt">Void</span>)</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>            <span class="ot">-&gt;</span> m (<span class="dt">Either</span> a (a <span class="ot">-&gt;</span> m <span class="dt">Void</span>))</span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>        go not_lem <span class="ot">=</span> <span class="fu">pure</span> <span class="op">.</span> <span class="dt">Right</span> <span class="op">$</span> not_lem <span class="op">.</span> <span class="dt">Left</span></span></code></pre></div>
<h3 id="lem-and-doublenegation">Lem and DoubleNegation</h3>
<div class="sourceCode" id="cb9"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Iso</span> (<span class="dt">Lem</span> m) (<span class="dt">DoubleNegation</span> m) <span class="kw">where</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    to ::</span> <span class="dt">Lem</span> m <span class="ot">-&gt;</span> <span class="dt">DoubleNegation</span> m</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    to (<span class="dt">Lem</span> lem) <span class="ot">=</span> <span class="dt">DoubleNegation</span> proof</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>      <span class="kw">where</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>        proof</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="ot">            ::</span> ((a <span class="ot">-&gt;</span> m <span class="dt">Void</span>) <span class="ot">-&gt;</span> m <span class="dt">Void</span>)</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>            <span class="ot">-&gt;</span> m a</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>        proof notNot <span class="ot">=</span> lem <span class="op">&gt;&gt;=</span> <span class="fu">either</span> <span class="fu">pure</span> (go notNot)</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>        go</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a><span class="ot">            ::</span> ((a <span class="ot">-&gt;</span> m <span class="dt">Void</span>) <span class="ot">-&gt;</span> m <span class="dt">Void</span>)</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>            <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m <span class="dt">Void</span>)</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>            <span class="ot">-&gt;</span> m a</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>        go notNot notA <span class="ot">=</span> <span class="fu">fmap</span> absurd <span class="op">$</span> notNot notA</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a><span class="ot">    from ::</span> <span class="dt">DoubleNegation</span> m <span class="ot">-&gt;</span> <span class="dt">Lem</span> m</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>    from (<span class="dt">DoubleNegation</span> dne) <span class="ot">=</span> <span class="dt">Lem</span> <span class="op">$</span> dne not_exists_dist</span></code></pre></div>
<h3 id="lem-and-demorgan">Lem and DeMorgan</h3>
<div class="sourceCode" id="cb10"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Iso</span> (<span class="dt">Lem</span> m) (<span class="dt">DeMorgan</span> m) <span class="kw">where</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    to ::</span> <span class="dt">Lem</span> m <span class="ot">-&gt;</span> <span class="dt">DeMorgan</span> m</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    to (<span class="dt">Lem</span> lem) <span class="ot">=</span> <span class="dt">DeMorgan</span> proof</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>      <span class="kw">where</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>        proof</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="ot">            ::</span> ((a <span class="ot">-&gt;</span> m <span class="dt">Void</span>, b <span class="ot">-&gt;</span> m <span class="dt">Void</span>) <span class="ot">-&gt;</span> m <span class="dt">Void</span>)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>            <span class="ot">-&gt;</span> m (<span class="dt">Either</span> a b)</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>        proof notNotANotB <span class="ot">=</span> lem <span class="op">&gt;&gt;=</span> <span class="fu">either</span> <span class="fu">pure</span> (go notNotANotB)</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>        go</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="ot">            ::</span> ((a <span class="ot">-&gt;</span> m <span class="dt">Void</span>, b <span class="ot">-&gt;</span> m <span class="dt">Void</span>) <span class="ot">-&gt;</span> m <span class="dt">Void</span>)</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>            <span class="ot">-&gt;</span> (<span class="dt">Either</span> a b <span class="ot">-&gt;</span> m <span class="dt">Void</span>)</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>            <span class="ot">-&gt;</span> m (<span class="dt">Either</span> a b)</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>        go notNotANotB <span class="ot">=</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>            <span class="fu">fmap</span> absurd</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span> notNotANotB</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span> liftA2 (,) (<span class="op">.</span> <span class="dt">Left</span>) (<span class="op">.</span> <span class="dt">Right</span>)</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a><span class="ot">    from ::</span> <span class="dt">DeMorgan</span> m <span class="ot">-&gt;</span> <span class="dt">Lem</span> m</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>    from (<span class="dt">DeMorgan</span> dm) <span class="ot">=</span> <span class="dt">Lem</span> <span class="op">$</span> dm go</span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>      <span class="kw">where</span></span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>        go</span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a><span class="ot">            ::</span> (a <span class="ot">-&gt;</span> m <span class="dt">Void</span>, (a <span class="ot">-&gt;</span> m <span class="dt">Void</span>) <span class="ot">-&gt;</span> m <span class="dt">Void</span>)</span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>            <span class="ot">-&gt;</span> m <span class="dt">Void</span></span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>        go (notA, notNotA) <span class="ot">=</span> notNotA notA</span></code></pre></div>
<h3 id="lem-and-impliestoor">Lem and ImpliesToOr</h3>
<div class="sourceCode" id="cb11"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Iso</span> (<span class="dt">Lem</span> m) (<span class="dt">ImpliesToOr</span> m) <span class="kw">where</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    to ::</span> <span class="dt">Lem</span> m <span class="ot">-&gt;</span> <span class="dt">ImpliesToOr</span> m</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    to (<span class="dt">Lem</span> lem) <span class="ot">=</span> <span class="dt">ImpliesToOr</span> proof</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>      <span class="kw">where</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>        proof</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="ot">            ::</span> (a <span class="ot">-&gt;</span> m b)</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>            <span class="ot">-&gt;</span> m (<span class="dt">Either</span> b (a <span class="ot">-&gt;</span> m <span class="dt">Void</span>))</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>        proof fab <span class="ot">=</span> <span class="fu">either</span> <span class="dt">Left</span> (go fab) <span class="op">&lt;$&gt;</span> lem</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>        go</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a><span class="ot">            ::</span> (a <span class="ot">-&gt;</span> m b)</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>            <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> m <span class="dt">Void</span>)</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>            <span class="ot">-&gt;</span> <span class="dt">Either</span> b (a <span class="ot">-&gt;</span> m <span class="dt">Void</span>)</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>        go fab notB <span class="ot">=</span> <span class="dt">Right</span> <span class="op">$</span> notB <span class="op">&lt;=&lt;</span> fab</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a><span class="ot">    from ::</span> <span class="dt">ImpliesToOr</span> m <span class="ot">-&gt;</span> <span class="dt">Lem</span> m</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>    from (<span class="dt">ImpliesToOr</span> im) <span class="ot">=</span> <span class="dt">Lem</span> <span class="op">$</span> im <span class="fu">pure</span></span></code></pre></div>
<p>The full source code is available on <a
href="https://github.com/eviefp/logic-in-haskell">my github</a>.</p>]]></content>
  </entry>
  <entry>
      <title>Curry-Howard Correspondence Example</title>
      <link href="https://eevie.ro/posts/2019-02-02-curry-howard.html"/>
      <id>https://eevie.roposts/2019-02-02-curry-howard.html</id>
      <updated>2019-02-02T00:00:SZ</updated>
      <category term="haskell"/>
      <category term="theory"/>
      <summary>More Logic in PL</summary>
      <content type="html"><![CDATA[<p>I previously showed some fun <a
href="/clasical-logic-in-haskell/">classical logic proofs in
Haskell</a>, thanks to the Curry-Howard correspondence.</p>
<p>This post will show how a simple proof works in Logic, Type Theory,
and Category Theory: given <code>A ∧ (B ∧ C)</code>, prove
<code>(A ∧ B) ∧ C</code>.</p>
<h2 id="logic">Logic</h2>
<p>In logic, there are several systems that allows us to reason about
propositions. One of them is the natural deduction system and is defined
using introduction and elimination rules. For each connective, or
operator, we will have at least one of each introduction and elimination
rules.</p>
<p>For example, conjunction (<code>∧</code>) has one introduction
rule:</p>
<pre><code> A   B
------- (∧i)
 A ∧ B</code></pre>
<p>which means, if we know <code>A</code> and <code>B</code>, then we
can use the introduction rule (<code>∧i</code>) to deduce the
proposition <code>A ∧ B</code>.</p>
<p>There are two elimination rules for <code>∧</code>:</p>
<pre><code>A ∧ B                 A ∧ B
----- (∧e1)           ----- (∧e2)
  A                     B</code></pre>
<p>which means, if we know <code>A ∧ B</code>, we can obtain
<code>A</code> or <code>B</code> if we use the elimination rules
<code>∧e1</code> or <code>∧e2</code>.</p>
<p>So, if we wanted to prove the conclusion<code>(A ∧ B) ∧ C)</code>
from the hypothesis <code>A ∧ (B ∧ C)</code>, we would have to: 1.
obtain an <code>A</code> by using <code>∧e1</code> on the hypothesis 2.
obtain a <code>B ∧ C</code> by using <code>∧e2</code> on the hypothesis
3. obtain a <code>B</code> by using <code>∧e1</code> on (2) 4. obtain a
<code>C</code> by using <code>∧e2</code> on (2) 5. obtain a
<code>A ∧ B</code> by using <code>∧i</code> on (1) and (3) 6. reach the
conclusion <code>(A ∧ B) ∧ C</code> by using <code>∧i</code> on (5) and
(4)</p>
<p>In natural deduction, it looks like this:</p>
<pre><code>A ∧ (B ∧ C)          A ∧ (B ∧ C)
----------- (∧e1)   ------------- (∧e2)
     A                   B ∧ C
     .              --- (∧e1)  --- (∧e2)
     A               B          C
  --------------------- (∧i)    .
          A ∧ B                 C
     ------------------------------- (∧i)
                (A ∧ B) ∧ C</code></pre>
<h2 id="type-theory">Type Theory</h2>
<p>The Curry-Howard correspondence tells us that conjunction translates
to pairs in type theory, so we'll switch notation to Haskell's tuple
type, using the following notation: - Types: capital letters
<code>A</code> <code>B</code> <code>C</code> <code>D</code> - Terms:
lowercase letters <code>a</code> <code>b</code> <code>c</code>
<code>d</code> - Tuple Types: <code>(A, B)</code> for the tuple
<code>A</code> <code>B</code> - Tuple Terms: <code>(a, b)</code> for the
tuple <code>a</code> <code>b</code> of type <code>(A, B)</code></p>
<p>Typed lambda calculus has a deduction system as well. Tuple
introduction looks very similar to <code>∧i</code>:</p>
<pre><code>  a : A    b : B
------------------ ((,)i)
 (a, b) : (A, B)</code></pre>
<p>which means, given a term <code>a</code> of type <code>A</code> and a
term <code>b</code> of type <code>B</code>, then we can obtain a term
<code>(a, b)</code> of type <code>(A, B)</code>. Note that we no longer
need to say <em>"given we know <code>A</code> and <code>B</code>"</em>,
since the existence of a term of each type is enough to form the
tuple.</p>
<p>Similarly, there are two elimination rules:</p>
<pre><code>  (a, b) : (A, B)                  (a, b) : (A, B)
------------------- ((,)e1)      ------------------- ((,)e2)
       a : A                            b : B</code></pre>
<p>which means, given a tuple <code>(a, b)</code> of type
<code>(A, B)</code> we can obtain a term <code>a</code> or
<code>b</code> of type <code>A</code> or <code>B</code>.</p>
<p>If we translate the proposition above, then we have to prove
<code>((A, B), C)</code> from <code>(A, (B, C))</code>.</p>
<pre><code>(a, (b, c) : (A, (B, C))          (a, (b, c)) : (A, (B, C))
------------------------ ((,)e1)  ------------------------- ((,)e2)
         a : A                         (b, c) : (B, C)
           .                        ------- ((,)e1) ------- ((,)e2)
         a : A                       b : B           c : C
  ----------------------------------------- ((,)i)     .  
                (a, b) : (A, B)                      c : C
            -------------------------------------------------- ((,)i)
                        ((a, b), c) : ((A, B), C)</code></pre>
<p>The form is identical to the logic proof, except we have terms and
the rules use <code>(,)</code> instead of <code>∧</code>.</p>
<h2 id="haskell-proof">Haskell Proof</h2>
<p>We can write the same thing in Haskell:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">assoc ::</span> (a, (b, c)) <span class="ot">-&gt;</span> ((a, b), c)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>assoc (a, (b, c)) <span class="ot">=</span> ((a, b), c)</span></code></pre></div>
<p>However, this takes advantage of a powerful Haskell feature known as
pattern matching.</p>
<p>Given the proof above, it's easy to noice that <code>(,)i</code> is
exactly the tuple constructor, <code>(,)e1</code> is <code>fst</code>
and <code>(,)e2</code> is <code>snd</code>. Knowing this, and looking at
the proof above, we could say, given hypothesis
<code>h = (a, (b, c)) : (A, (B, C))</code>, we can obtain:</p>
<ol>
<li><code>a : A</code> from <code>fst h</code></li>
<li><code>(b, c) : (B, C)</code> from <code>snd h</code></li>
<li><code>b : B</code> from <code>fst (snd h)</code></li>
<li><code>c : C</code> from <code>snd (snd h)</code></li>
<li><code>(a, b) : (A, B)</code> from
<code>(fst h, fst (snd h))</code></li>
<li><code>((a, b), c) : ((A, B), C)</code> from
<code>((fst h, fst (snd h)), snd (snd h))</code></li>
</ol>
<p>So, in Haskell:</p>
<pre><code>assoc&#39; :: (a, (b, c)) -&gt; ((a, b), c)
assoc&#39; h = ((fst h, fst (snd h)), snd (snd h))</code></pre>
<p>This is a neat effect of the Curry-Howard correspondence: proofs are
programs. So, once we write the proof, we also have the program. We
could even write the program and then extract the proof -- it's really
the same thing.</p>
<h2 id="category-theory">Category Theory</h2>
<p>The Curry-Howard-Lambek extends the correspondence to include CT as
well. The correspondence connects propositions to objects, arrows to
implication, conjunction to categorical products, etc.</p>
<p>While in logic we said "given a proof of <code>A</code>", and in type
theory we said "given a term of type <code>A</code>", the only way we
can do the same in CT is to say "given an arrow from the terminal object
<code>T</code> to <code>A</code>, <code>f : T → A</code>". This works
because the terminal object represents <code>True</code> /
<code>Unit</code> in logic / type theory, so it means "given we can
deduce <code>A</code> from <code>True</code>", or "given we can obtain a
term <code>a : A</code> from <code>() : ()</code>".</p>
<p>Armed with this, we can now express the same problem in CT terms: -
given an arrow <code>h : T → (A × (B × C))</code> - obtain an arrow
<code>p : T → ((A × B) × C))</code></p>
<p>Before we begin, let's review what a product is: - given
<code>A × B</code>, we know there are two arrows
<code>p : A × B → A</code> and <code>q : A × B → B</code>, which we will
write as <code>&lt;p, q&gt;</code> - given <code>A × B</code> is the
product of <code>A</code> and <code>B</code>, and <code>C</code> is an
object with two arrows <code>p' : C → A</code> and
<code>q' : C → B</code>, there exists an unique arrow
<code>m : C → A × B</code> such that <code>p ∘ m = p'</code> and
<code>q ∘ m = q'</code></p>
<p>Also, remember that we can compose any two arrows
<code>f : A → B</code> and <code>g : B → C</code> via
<code>g ∘ f</code>.</p>
<p>Now we are ready for the proof:</p>
<p><code>T</code> is the terminal object, and
<code>t : T → A × (B × C)</code> is what we start with. We need to be
able to obtain an arrow <code>t' : T → (A × B) × C)</code>.</p>
<p><img src="/images/curry-howard/ct1.jpg" title="ct1" alt="ct1" /></p>
<p>By <strong>product</strong> <code>A × (B × C)</code>, we know there
exists <code>p : A × (B × C) → A</code> and
<code>q : A × (B × C) → B × C</code>.</p>
<p>By <strong>composition</strong>, we can obtain the arrows
<code>p ∘ t : T → A</code> and <code>q ∘ t : T → B × C</code>.</p>
<p>By <strong>product</strong> <code>B × C</code>, we know there exists
<code>p' : B × C → B</code> and <code>q' : B × C → C</code>.</p>
<p>By <strong>composition</strong>, we can obtain the arrow
<code>p' ∘ q ∘ t : T → B</code>.</p>
<p>So now, we have the following arrows: - <code>p ∘ t : T → A</code> -
<code>p' ∘ q ∘ t : T → B</code></p>
<p><img src="/images/curry-howard/ct2.jpg" title="ct2" alt="ct2" /></p>
<p>By definition of <strong>product</strong>, since we know
<code>A × B</code> is the product of <code>A</code> and <code>B</code>,
and since we have the arrows <code>T → A</code> and <code>T → B</code>,
then we know there must be an unique arrow which we'll name
<code>l : T → A × B</code>.</p>
<p>By <strong>composition</strong> we can obtain the arrow
<code>q' ∘ q ∘ t : T → C</code>.</p>
<p><img src="/images/curry-howard/ct3.jpg" title="ct3" alt="ct3" /></p>
<p>Similarly to the step before, by definition of
<strong>product</strong>, since we know <code>(A × B) × C</code> is a
product of <code>A × B</code> and <code>C</code>, and since we have the
arrows <code>l : T → A × B</code> and <code>q' ∘ q ∘ t : T → C</code>,
then there must exist an unique arrow
<code>t' : T → (A × B) × C</code>.</p>
<p>Note: there are, in fact, as many arrows <code>T → (A × B) × C</code>
as are elements in <code>(A × B) × C</code>, but <code>t'</code> is the
unique one derived from the initial arrow, <code>t</code>.</p>
<p><img src="/images/curry-howard/ct4.jpg" title="ct4" alt="ct4" /></p>
<p>Edit: See this <a
href="https://twitter.com/BartoszMilewski/status/1093565646036643841">twitter
thread for a whiteboard proof of sum associativity</a>.</p>
<h2 id="back-to-haskell">Back to Haskell</h2>
<p>If we follow the CT arrows as we followed the logic proof: - we could
rewrite the <code>l : T → A × B</code> arrow as
<code>&lt;i,j&gt; : T → A × B</code>, where
<code>i = p ∘ t : T → A</code> and <code>j = p' ∘ q ∘ t : T → B</code>.
- we already have <code>k = q' ∘ q ∘ t : T → C</code></p>
<p>So, if instead of <code>t</code> we write <code>a_bc</code> to denote
our hypothesis, or inputs, let's look closer at what <code>i</code>,
<code>j</code> and <code>k</code> are: - <code>i</code> is
<code>p ∘ t</code>, which is the left projection of the premise, or
<code>fst a_bc</code></p>
<p>You may ask: Why?!? Well, <code>p ∘ t</code> means
<code>p after t</code>. In our case, <code>t</code> represents the
input, so it's equivalent to <code>a_bc</code>, and <code>p</code> is
the left projection, which is equivalent to <code>fst</code>. Keep in
mind that <code>a ∘ b ∘ c</code> means
<code>c first, then b, then a</code> when reading the following.</p>
<ul>
<li><code>j</code> is <code>p' ∘ q ∘ t</code>, which is
<code>fst (snd a_bc)</code></li>
<li><code>l = &lt;i,j&gt;</code>, so
<code>l = (fst a_bc, fst (snd a_bc))</code></li>
<li><code>k</code> is <code>snd (snd a_bc)</code></li>
<li>the result, <code>T → (A × B) × C</code> is
<code>&lt; &lt;i,j&gt;, k &gt; = ((fst a_bc, fst (snd a_bc)), snd (snd a_bc))</code></li>
</ul>
<p>If we look back at the Haskell definition:
<code>assoc a_bc = ((fst a_bc, fst (snd a_bc)), snd (snd a_bc))</code></p>
<p>Which means we reached the same implementation/proof, again.</p>
<p>Edit: Thank you to <a
href="https://twitter.com/BartoszMilewski">Bartosz Milewski</a> and <a
href="https://github.com/glmxndr">GhiOm</a> for their <a
href="https://github.com/eviefp/eviefp.github.io/issues/1">early
feedback</a>.</p>]]></content>
  </entry>
  <entry>
      <title>Quantifiers in Agda</title>
      <link href="https://eevie.ro/posts/2019-02-17-quantifiers.html"/>
      <id>https://eevie.roposts/2019-02-17-quantifiers.html</id>
      <updated>2019-02-17T00:00:SZ</updated>
      <category term="agda"/>
      <category term="dependent types"/>
      <summary>Forall and Exists as Dependent Types</summary>
      <content type="html"><![CDATA[<p>I previously showed a <a href="/curry-howard">single proof</a> in
logic, type theory, and category theory, and some fun <a
href="/clasical-logic-in-haskell/">classical logic proofs in
Haskell</a>, thanks to the Curry-Howard correspondence.</p>
<p>This post will go a bit further than that and show the type theoretic
equivalents of existential and universal quantifiers. I'll then explore
some interesting properties of these types. This post will not go into
the category theory part of this, although I may do that in a future
post.</p>
<h2 id="quantifiers-in-logic">Quantifiers in Logic</h2>
<p>Forall (∀) is the universal quantifier and is generally written
as</p>
<pre><code>∀ x. P x</code></pre>
<p>where <code>x</code> is a variable and <code>P</code> is a predicate
taking such a variable. A basic example of such a proposition could be:
<em>"For all numbers x, if you add one to x, you get a greater number
than x"</em>, or:</p>
<pre><code>∀ x. x + 1 &gt; x</code></pre>
<p>Similarly, exists (∃) is the existential quantifier and is written
as</p>
<pre><code>∃ x. P x</code></pre>
<p>where <code>x</code> is a variable and <code>P</code> is a predicate,
for example: <em>"there exists a number that is greater than 10"</em>,
or:</p>
<pre><code>∃ x. x &gt; 10</code></pre>
<p>Please note that in classical logic, you can prove an existential
proposition by either finding an <code>x</code> for which
<code>P(x)</code> is <em>true</em>, or by assuming there does not exist
such an <code>x</code> and reaching a contradiction (<a
href="https://en.wikipedia.org/wiki/Proof_by_contradiction">proof by
contradiction</a>). In <em>intuitionistic</em> logic, the latter is not
possible: we have to find the <code>x</code>. One could then say that an
existential quantifier in intuitionistic logic is described by a pair of
<code>x</code> and <code>P(x)</code>.</p>
<p>In the next chapter, we will look at dependent sum and I will say
it's the Curry-Howard correspondent of existential quantifiers. Most
theorem provers that rely on this correspondence will use make use of <a
href="https://www.cs.cmu.edu/~fp/courses/15317-f08/lectures/08-irrelevance.pdf">proof
irrelevance</a> which essentially means that it should not matter
whether one picks <code>11</code> or <code>12</code> in order to to
prove <code>∃ x. x &gt; 10</code>: the proofs should be equivalent. We
will not look into this, nor will we make use of proof irrelevance in
this post.</p>
<h2 id="dependent-sum">Dependent Sum</h2>
<p>Dependent sums (Σ) are the type theoretic equivalent of existential
quantifiers. In Agda, we can define the dependent sum type as:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> Σ {<span class="dt">A</span> <span class="op">:</span> <span class="dt">Set</span>} (<span class="dt">P</span> <span class="op">:</span> <span class="dt">A</span> → <span class="dt">Set</span>) <span class="op">:</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    Σ_intro <span class="op">:</span> ∀ (a <span class="op">:</span> <span class="dt">A</span>) → <span class="dt">P</span> a → Σ <span class="dt">P</span></span></code></pre></div>
<p>The ∑ type is a higher-kinded type which takes a higher-kinded type,
<code>P : A → Set</code> -- <code>P</code> takes an <code>A</code> and
gives us a new type (<code>Set</code>, in Agda). The nice part about
this is that <code>P</code> holds information about both the type of the
existential variable (<code>A</code>) as well as the type of the
resulting type (<code>P A</code>).</p>
<p>Constructing such a term requires a term of the existential type
(<em>evidence</em> for <code>A</code>), and a term of the predicate type
(<em>evidence</em> for <code>P A</code>). For example, the example above
could be written as <code>∑_intro 11 (11 &gt; 10)</code>, assuming there
exists a type <code>&gt;</code> which expresses the greater-than
relationship.</p>
<p>Please note that the above example is a simplification and going into
the details of how an inductive type for <code>&gt;</code> works is
beyond the scope of this post.</p>
<h2 id="dependent-product">Dependent Product</h2>
<p>Dependent products (∏) are the type theoretic equivalent of universal
quantifiers. In Agda, we can define the dependent product type as:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> Π {<span class="dt">A</span> <span class="op">:</span> <span class="dt">Set</span>} (<span class="dt">P</span> <span class="op">:</span> <span class="dt">A</span> → <span class="dt">Set</span>) <span class="op">:</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    Π_intro <span class="op">:</span> (∀ (a <span class="op">:</span> <span class="dt">A</span>) → <span class="dt">P</span> a) → Π <span class="dt">P</span></span></code></pre></div>
<p>The ∏ type is also a higher-kinded type. Note that this definition is
almost identical to the Σ definition, except for the parantheses used in
the constructor (<code>Π_intro</code>). This lines up with the intuition
that <code>∀x. P(X)</code> can be described by a function
<code>A -&gt; P(x)</code>, where <code>x : A</code>.</p>
<p>Constructing a ∏ type takes a function from the quantified variable
to the type described by the predicate.</p>
<p>Constructing a term would, for example be
<code>∏_intro (λn. n + 1 &gt; n)</code>.</p>
<h2 id="tuples---special-case-of-dependent-sum">Tuples - Special Case of
Dependent Sum</h2>
<p>We will first need to define a <code>constT</code> function:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>constT <span class="op">:</span> ∀ (<span class="dt">X</span> <span class="op">:</span> <span class="dt">Set</span>) (<span class="dt">Y</span> <span class="op">:</span> <span class="dt">Set</span>) → <span class="dt">Y</span> → <span class="dt">Set</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>constT x _ _ <span class="ot">=</span> x</span></code></pre></div>
<p>This takes two types, <code>X</code> and <code>Y</code>. It then
takes a value of type <code>Y</code>, and ignores it, returning the type
<code>X</code>.</p>
<p>So, if we take <code>P</code> to <em>not</em> depend on the
quantified item and define it using <code>constT</code>, then we can
obtain tuples in the case of ∑ types:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>Σ<span class="op">-</span>pair <span class="op">:</span> ∀ (<span class="dt">A</span> <span class="dt">B</span> <span class="op">:</span> <span class="dt">Set</span>) → <span class="dt">Set</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>Σ<span class="op">-</span>pair a b <span class="ot">=</span> Σ (constT b a)</span></code></pre></div>
<p>Note that <code>Σ-pair</code> is a type-level function that takes two
types and returns the type of pairs.</p>
<p>We can then define a simple pair constructor using the constructor
above:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>Σ<span class="op">-</span>mkPair <span class="op">:</span> ∀ {<span class="dt">A</span> <span class="op">:</span> <span class="dt">Set</span>}  {<span class="dt">B</span> <span class="op">:</span> <span class="dt">Set</span>} → <span class="dt">A</span> → <span class="dt">B</span> → Σ<span class="op">-</span>pair <span class="dt">A</span> <span class="dt">B</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>Σ<span class="op">-</span>mkPair a b <span class="ot">=</span> Σ_intro a b</span></code></pre></div>
<p>And we can have the two projections by simple pattern match,
returning the appropriate value:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>Σ<span class="op">-</span><span class="fu">fst</span> <span class="op">:</span> ∀ {<span class="dt">A</span> <span class="dt">B</span> <span class="op">:</span> <span class="dt">Set</span>} → Σ<span class="op">-</span>pair <span class="dt">A</span> <span class="dt">B</span> → <span class="dt">A</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>Σ<span class="op">-</span><span class="fu">fst</span> (Σ_intro a _) <span class="ot">=</span> a</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>Σ<span class="op">-</span><span class="fu">snd</span> <span class="op">:</span> ∀ {<span class="dt">A</span> <span class="dt">B</span> <span class="op">:</span> <span class="dt">Set</span>} → Σ<span class="op">-</span>pair <span class="dt">A</span> <span class="dt">B</span> → <span class="dt">B</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>Σ<span class="op">-</span><span class="fu">snd</span> (Σ_intro _ b) <span class="ot">=</span> b</span></code></pre></div>
<p>This works because Σ types are defined as
<code>a -&gt; P a -&gt; Σ P</code>, so if we take a <code>P</code> such
that <code>P a</code> always is <code>b</code>, then we get
<code>a -&gt; b -&gt; Σ</code> which is essentially a tuple of
<code>a</code> and <code>b</code>.</p>
<p>We can now say <code>Σ_snd (Σ_mkPair 1 2)</code> and get the result
<code>2</code>.</p>
<h2 id="functions---special-case-of-dependent-product">Functions -
Special Case of Dependent Product</h2>
<p>Similarly, if we take <code>P</code> to be <code>const B A</code>, we
can obtain functions out of ∏ types:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>Π<span class="op">-</span>function <span class="op">:</span> ∀ (<span class="dt">A</span> <span class="dt">B</span> <span class="op">:</span> <span class="dt">Set</span>) → <span class="dt">Set</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>Π<span class="op">-</span>function a b <span class="ot">=</span> Π (constT b a)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>Π<span class="op">-</span>mkFunction <span class="op">:</span> ∀ {<span class="dt">A</span> <span class="dt">B</span> <span class="op">:</span> <span class="dt">Set</span>} → (<span class="dt">A</span> → <span class="dt">B</span>) → Π<span class="op">-</span>function <span class="dt">A</span> <span class="dt">B</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>Π<span class="op">-</span>mkFunction f <span class="ot">=</span> Π_intro f</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>Π<span class="op">-</span>apply <span class="op">:</span> ∀ {<span class="dt">A</span> <span class="dt">B</span> <span class="op">:</span> <span class="dt">Set</span>} → Π<span class="op">-</span>function <span class="dt">A</span> <span class="dt">B</span> → <span class="dt">A</span> → <span class="dt">B</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>Π<span class="op">-</span>apply (Π_intro f) a <span class="ot">=</span> f a</span></code></pre></div>
<p>As with sum types, this works because Π types are defined as
<code>(a -&gt; P a) -&gt; Π P</code>, so if we take <code>P</code> such
that <code>P a</code> always is <code>b</code>, then we get
<code>(a -&gt; b) -&gt; Π</code>, which is essentially a function from
<code>a</code> to <code>b</code>.</p>
<p>We can now write <code>Π-apply (Π-mkFunction (λx. x + 1)) 1</code>
and get the result <code>2</code>.</p>
<h2 id="what-about-sum-types">What About Sum Types?</h2>
<p>We can obtain sum types from ∑ types by using <code>Bool</code> as
the variable type, and the predicate <em>returning</em> type
<code>A</code> for <code>true</code>, and type <code>B</code> for
<code>false</code>:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>bool <span class="op">:</span> ∀ (<span class="dt">A</span> <span class="dt">B</span> <span class="op">:</span> <span class="dt">Set</span>) → <span class="dt">Bool</span> → <span class="dt">Set</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>bool a _ true  <span class="ot">=</span> a</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>bool _ b false <span class="ot">=</span> b</span></code></pre></div>
<p>Note that <code>a</code> and <code>b</code> are types! We can now
write:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>Σ<span class="op">-</span><span class="fu">sum</span> <span class="op">:</span> ∀ (<span class="dt">A</span> <span class="dt">B</span> <span class="op">:</span> <span class="dt">Set</span>) → <span class="dt">Set</span> </span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>Σ<span class="op">-</span><span class="fu">sum</span> a b <span class="ot">=</span> Σ (bool a b)</span></code></pre></div>
<p>Now, in order to construct such a type (via <em>left</em> or
<em>right</em>), we just need to pass the appropriate boolean value
along with an item of the correct type:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>Σ<span class="op">-</span>sum_left <span class="op">:</span> ∀ {<span class="dt">A</span> <span class="op">:</span> <span class="dt">Set</span>} (<span class="dt">B</span> <span class="op">:</span> <span class="dt">Set</span>) → <span class="dt">A</span> → Σ<span class="op">-</span><span class="fu">sum</span> <span class="dt">A</span> <span class="dt">B</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>Σ<span class="op">-</span>sum_left _ a <span class="ot">=</span> Σ_intro true a</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>Σ<span class="op">-</span>sum_right <span class="op">:</span> ∀ {<span class="dt">B</span> <span class="op">:</span> <span class="dt">Set</span>} (<span class="dt">A</span> <span class="op">:</span> <span class="dt">Set</span>) → <span class="dt">B</span> → Σ<span class="op">-</span><span class="fu">sum</span> <span class="dt">A</span> <span class="dt">B</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>Σ<span class="op">-</span>sum_right _ b <span class="ot">=</span> Σ_intro false b</span></code></pre></div>
<p>Eliminating is just a matter of pattern matching on the boolean value
and applying the correct function:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>Σ<span class="op">-</span>sum_elim <span class="op">:</span> ∀ {<span class="dt">A</span> <span class="dt">B</span> <span class="dt">R</span> <span class="op">:</span> <span class="dt">Set</span>} → (<span class="dt">A</span> → <span class="dt">R</span>) → (<span class="dt">B</span> → <span class="dt">R</span>) → Σ<span class="op">-</span><span class="fu">sum</span> <span class="dt">A</span> <span class="dt">B</span> → <span class="dt">R</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>Σ<span class="op">-</span>sum_elim f _ (Σ_intro true  a) <span class="ot">=</span> f a</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>Σ<span class="op">-</span>sum_elim _ g (Σ_intro false b) <span class="ot">=</span> g b</span></code></pre></div>
<p>As an example,
<code>Σ-sum_elim (const "left") (const "right") (Σ-sum_left Bool 1)</code>,
and get the result <code>"left"</code>.</p>
<p>Interestingly, we can also obtain sum types from ∏ types: the idea is
to encode the eliminator right into our type! For that we will need the
following predicate:</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>prodPredicate <span class="op">:</span> ∀ (<span class="dt">A</span> <span class="dt">B</span> <span class="dt">R</span> <span class="op">:</span> <span class="dt">Set</span>) → <span class="dt">Set</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>prodPredicate a b r <span class="ot">=</span> (a → r) → (b → r) → r</span></code></pre></div>
<p>This means that given two types <code>A</code> and <code>B</code>, we
get a type-level function from <code>R</code> to
<code>(A -&gt; R) -&gt; (B -&gt; R) -&gt; R</code>, which is exactly the
eliminator type. Don't worry about <code>Set₁</code> or <code>Π'</code>
for now:</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>Π<span class="op">-</span><span class="fu">sum</span> <span class="op">:</span> ∀ (<span class="dt">A</span> <span class="dt">B</span> <span class="op">:</span> <span class="dt">Set</span>) → <span class="dt">Set</span>₁</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>Π<span class="op">-</span><span class="fu">sum</span> a b <span class="ot">=</span> Π&#39; (prodPredicate a b)</span></code></pre></div>
<p>This means that in order to build a sum type, we need to pass a type
<code>R</code> and a function
<code>(A -&gt; R) -&gt; (B -&gt; R) -&gt; R</code>. So, the constructors
will look like:</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>Π<span class="op">-</span><span class="fu">sum</span><span class="op">-</span>left <span class="op">:</span> ∀ {<span class="dt">A</span> <span class="op">:</span> <span class="dt">Set</span>} (<span class="dt">B</span> <span class="op">:</span> <span class="dt">Set</span>) → <span class="dt">A</span> → Π<span class="op">-</span><span class="fu">sum</span> <span class="dt">A</span> <span class="dt">B</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>Π<span class="op">-</span><span class="fu">sum</span><span class="op">-</span>left _ a <span class="ot">=</span> Π&#39;_intro (\_ f _ → f a)</span></code></pre></div>
<p>The lambda is the only interesting bit: we construct a function that
given a type <code>R</code> (first <code>_</code>) and a function
<code>A -&gt; R</code> (named <code>f</code>), we can return an
<code>R</code> by calling <code>f a</code> (the third <code>_</code>
parameter is for the function <code>g : B -&gt; R</code>, which is not
required for the <em>left</em> constructor).</p>
<p>Similarly, we can write a constructor for <em>right</em>:</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>Π<span class="op">-</span><span class="fu">sum</span><span class="op">-</span>right <span class="op">:</span> ∀ {<span class="dt">A</span> <span class="op">:</span> <span class="dt">Set</span>} (<span class="dt">B</span> <span class="op">:</span> <span class="dt">Set</span>) → <span class="dt">B</span> → Π<span class="op">-</span><span class="fu">sum</span> <span class="dt">A</span> <span class="dt">B</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>Π<span class="op">-</span><span class="fu">sum</span><span class="op">-</span>right _ b <span class="ot">=</span> Π&#39;_intro (\_ _ g → g b)</span></code></pre></div>
<p>As for the eliminator, we simply require the two functions
<code>A -&gt; R</code> and <code>B -&gt; R</code> in order to pass to
our dependent product and get an <code>R</code>:</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>Π<span class="op">-</span><span class="fu">sum</span><span class="op">-</span>elim <span class="op">:</span> ∀ {<span class="dt">A</span> <span class="dt">B</span> <span class="dt">R</span> <span class="op">:</span> <span class="dt">Set</span>} → (<span class="dt">A</span> → <span class="dt">R</span>) → (<span class="dt">B</span> → <span class="dt">R</span>) → Π<span class="op">-</span><span class="fu">sum</span> <span class="dt">A</span> <span class="dt">B</span> → <span class="dt">R</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>Π<span class="op">-</span><span class="fu">sum</span><span class="op">-</span>elim f g (Π&#39;_intro elim) <span class="ot">=</span> elim _ f g</span></code></pre></div>
<h2 id="conclusions">Conclusions</h2>
<p>We've used three type-level functions to generate a few interesting
types:</p>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Σ-type</th>
<th>Π-type</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>constT</td>
<td>tuple</td>
<td>function</td>
</tr>
<tr class="even">
<td>bool</td>
<td>either</td>
<td>tuple</td>
</tr>
<tr class="odd">
<td>prodPredicate</td>
<td>-</td>
<td>either</td>
</tr>
</tbody>
</table>
<p>What other interesting type-level functions can you find for Σ and/or
Π types?</p>
<p>You can find the <a href="/content/quantifiers/DT.agda">source file
here</a>.</p>]]></content>
  </entry>
  <entry>
      <title>Functor-Of</title>
      <link href="https://eevie.ro/posts/2019-05-12-functor-of.html"/>
      <id>https://eevie.roposts/2019-05-12-functor-of.html</id>
      <updated>2019-05-12T00:00:SZ</updated>
      <category term="haskell"/>
      <category term="functor"/>
      <summary>Towards a more general Functor class</summary>
      <content type="html"><![CDATA[<p>Due to kind restrictions, the Haskell <em>Functor</em> cannot
represent a lot of valid functors: functors of higher kinded types
(higher than <code>* -&gt; *</code>), contravariant functors, invariant
functors, etc.</p>
<p>This post will show an alternate <code>Functor</code> that can handle
all of the above. I got this idea from the awesome <a
href="https://twitter.com/am_i_tom">Tom Harding</a>, and he apparently
got it from <a
href="https://twitter.com/Iceland_jack">@Iceland_jack</a>.</p>
<p>Although this is not new, I could not find any blog post or paper
covering it.</p>
<h2 id="the-actual-problem">The actual problem</h2>
<p>The problem is quite straight-forward. Let's say we want to define a
functor instance for <code>(a, b)</code> which changes the
<code>a</code>, to <code>c</code> using an <code>a -&gt; c</code>
function. This should be possible, but there is no way to write it using
<code>Functor</code> and <code>fmap</code>.</p>
<p>There are two ways to do this in Haskell using <code>Prelude</code>:
- by using <code>Bifunctor</code>/<code>first</code>, or - by using the
<code>Flip</code> newtype.</p>
<p>While both the above options work, they are not particularly elegant.
On top of that, there is no common <em>Trifunctor</em> package, and
flipping arguments around and wrapping/unwrapping newtypes is not very
appealing, which means the approach doesn't quite scale well.</p>
<h2 id="functorof-to-the-rescue">FunctorOf to the rescue</h2>
<p>There are two problems with <code>Functor</code>: - <code>f</code>
has the wrong kind if we want to allow higher kinded functors, and - the
arrow of the mapped function is the wrong type if we want to allow
contravariant or invariant functors (or even other types of
mappings!).</p>
<p>We can fix both problems by adding additional types to the class:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">FunctorOf</span> (<span class="ot">p ::</span> k <span class="ot">-&gt;</span> k <span class="ot">-&gt;</span> <span class="dt">Type</span>) (<span class="ot">q ::</span> l <span class="ot">-&gt;</span> l <span class="ot">-&gt;</span> <span class="dt">Type</span>) f <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  map ::</span> p a b <span class="ot">-&gt;</span> q (f a) (f b)</span></code></pre></div>
<p><code>p</code> represents a relationshiop (arrow) between
<code>a</code> and <code>b</code>. In case of a regular functor, it's
just <code>-&gt;</code>, but we can change it to a reverse arrow for
contravariants.</p>
<p><code>q</code> is normally just an optional layer on top of
<code>-&gt;</code>, in order to allow mapping over other arguments. For
example, if we want to map over the second-to-last argument, we'd use
natural transforms (<code>~&gt;</code>).</p>
<p>The regular functor instance can be obtained by simply:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">FunctorOf</span> (<span class="ot">-&gt;</span>) (<span class="ot">-&gt;</span>) f <span class="kw">where</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  map ::</span> <span class="kw">forall</span> a b<span class="op">.</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">map</span> <span class="ot">=</span> <span class="fu">fmap</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="ot">functorExample ::</span> [<span class="dt">String</span>]</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>functorExample <span class="ot">=</span> <span class="fu">map</span> <span class="fu">show</span> ([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>]<span class="ot"> ::</span> [<span class="dt">Int</span>])</span></code></pre></div>
<h2 id="functor-for-hkd">Functor for HKD</h2>
<p>I'll use the <code>Bifunctor</code> instance in order to show all
bifunctors can have such a <code>FunctorOf</code> instance. Of course,
one could define instances manually for any <code>Bifunctor</code>.</p>
<p>Going back to our original example, we can define a
<code>FunctorOf</code> instance for <code>* -&gt; * -&gt; *</code> types
in the first argument via:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> (<span class="op">~&gt;</span>) f g <span class="ot">=</span> <span class="dt">Natural</span> (<span class="kw">forall</span> x<span class="op">.</span> f x <span class="ot">-&gt;</span> g x)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Bifunctor</span> f <span class="ot">=&gt;</span> <span class="dt">FunctorOf</span> (<span class="ot">-&gt;</span>) (<span class="op">~&gt;</span>) f <span class="kw">where</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  map ::</span> <span class="kw">forall</span> a b<span class="op">.</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="op">~&gt;</span> f b</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">map</span> f <span class="ot">=</span> <span class="dt">Natural</span> <span class="op">$</span> first f</span></code></pre></div>
<p>In order to avoid fiddling about with newtypes, we can define a
helper <code>bimap'</code> function for <code>* -&gt; * -&gt; *</code>
that maps both arguments:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>bimap&#39;</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> <span class="kw">forall</span> a b c d f</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span>  <span class="dt">FunctorOf</span> (<span class="ot">-&gt;</span>) (<span class="ot">-&gt;</span>) (f a)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=&gt;</span> <span class="dt">FunctorOf</span> (<span class="ot">-&gt;</span>) (<span class="op">~&gt;</span>) f</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b)</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> d)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> f a c</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> f b d</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>bimap&#39; f g fac <span class="ot">=</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> <span class="fu">map</span> f <span class="kw">of</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Natural</span> a2b <span class="ot">-&gt;</span> a2b (<span class="fu">map</span> g fac)</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="ot">bifunctorExample ::</span> (<span class="dt">String</span>, <span class="dt">String</span>)</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>bifunctorExample <span class="ot">=</span> bimap&#39; <span class="fu">show</span> <span class="fu">show</span> (<span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span>, <span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span>)</span></code></pre></div>
<h2 id="contravariant">Contravariant</h2>
<p>Okay, cool. But what about <em>contravariant</em> functors? We can
use <code>Op</code> from <code>Data.Functor.Contravariant</code>
(defined as <code>data Op a b = Op (b -&gt; a)</code>):</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Contravariant</span> f <span class="ot">=&gt;</span> <span class="dt">FunctorOf</span> <span class="dt">Op</span> (<span class="ot">-&gt;</span>) f <span class="kw">where</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  map ::</span> <span class="kw">forall</span> a b<span class="op">.</span> (<span class="dt">Op</span> b a) <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f a</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">map</span> (<span class="dt">Op</span> f) <span class="ot">=</span> contramap f</span></code></pre></div>
<p>This is pretty cool since we only need to change the mapped
function's type to be <code>Op</code> instead of <code>-&gt;</code>! As
before, we can make things easier by defining a helper:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>cmap</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> <span class="kw">forall</span> a b f</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span>  <span class="dt">FunctorOf</span> <span class="dt">Op</span> (<span class="ot">-&gt;</span>) f</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> a)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> f a</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> f b</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>cmap f fa <span class="ot">=</span> <span class="fu">map</span> (<span class="dt">Op</span> f) fa</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="ot">contraExample ::</span> <span class="dt">Predicate</span> <span class="dt">Int</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>contraExample <span class="ot">=</span> cmap <span class="fu">show</span> (<span class="dt">Predicate</span> (<span class="op">==</span> <span class="st">&quot;5&quot;</span>))</span></code></pre></div>
<h2 id="what-about-profunctors">What about Profunctors?</h2>
<p>I'm glad you asked! It's as easy as 1-2-3, or well, as easy as
"functor in the last argument" - "contravariant in the previous" -
"write helper function":</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Profunctor</span> p <span class="ot">=&gt;</span> <span class="dt">FunctorOf</span> <span class="dt">Op</span> (<span class="op">~&gt;</span>) p <span class="kw">where</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  map ::</span> <span class="kw">forall</span> a b<span class="op">.</span> (<span class="dt">Op</span> b a) <span class="ot">-&gt;</span> p b <span class="op">~&gt;</span> p a</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">map</span> (<span class="dt">Op</span> f) <span class="ot">=</span> <span class="dt">Natural</span> <span class="op">$</span> lmap f</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>dimap&#39;</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> <span class="kw">forall</span> a b c d p</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span>  <span class="dt">FunctorOf</span> (<span class="ot">-&gt;</span>) (<span class="ot">-&gt;</span>) (p a)</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=&gt;</span> <span class="dt">FunctorOf</span> <span class="dt">Op</span>   (<span class="op">~&gt;</span>) p</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> a)</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> d)</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> p a c</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> p b d</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>dimap&#39; f g pac <span class="ot">=</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> <span class="fu">map</span> (<span class="dt">Op</span> f) <span class="kw">of</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Natural</span> b2a <span class="ot">-&gt;</span> b2a (<span class="fu">map</span> g pac)</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a><span class="ot">profunctorExample ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>profunctorExample <span class="ot">=</span> dimap&#39; <span class="fu">read</span> <span class="fu">show</span> (<span class="op">+</span> (<span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span>))</span></code></pre></div>
<h2 id="trifunctors">Tri..functors?</h2>
<p>Yep. We only need to define a higher-kinded natural transform and
write the <code>FunctorOf</code> instance, along with the helper:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> (<span class="op">~~&gt;</span>) f g <span class="ot">=</span> <span class="dt">NatNat</span> (<span class="kw">forall</span> x<span class="op">.</span> f x <span class="op">~&gt;</span> g x)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Triple</span> a b c <span class="ot">=</span> <span class="dt">Triple</span> a b c <span class="kw">deriving</span> (<span class="dt">Functor</span>)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="ot">{-# overlapping #-}</span> <span class="dt">FunctorOf</span> (<span class="ot">-&gt;</span>) (<span class="op">~&gt;</span>) (<span class="dt">Triple</span> x) <span class="kw">where</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="ot">  map ::</span> <span class="kw">forall</span> a b<span class="op">.</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Triple</span> x a <span class="op">~&gt;</span> <span class="dt">Triple</span> x b</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">map</span> f <span class="ot">=</span> <span class="dt">Natural</span> <span class="op">$</span> \(<span class="dt">Triple</span> x a y) <span class="ot">-&gt;</span> <span class="dt">Triple</span> x (f a) y</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">FunctorOf</span> (<span class="ot">-&gt;</span>) (<span class="op">~~&gt;</span>) <span class="dt">Triple</span> <span class="kw">where</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="ot">  map ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Triple</span> a <span class="op">~~&gt;</span> <span class="dt">Triple</span> b</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">map</span> f <span class="ot">=</span> <span class="dt">NatNat</span> <span class="op">$</span> <span class="dt">Natural</span> <span class="op">$</span> \(<span class="dt">Triple</span> a x y) <span class="ot">-&gt;</span> <span class="dt">Triple</span> (f a) x y</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>triple</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> <span class="kw">forall</span> a b c d e f t</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span>  <span class="dt">FunctorOf</span> (<span class="ot">-&gt;</span>) (<span class="ot">-&gt;</span>)  (t a c)</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=&gt;</span> <span class="dt">FunctorOf</span> (<span class="ot">-&gt;</span>) (<span class="op">~&gt;</span>)  (t a)</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=&gt;</span> <span class="dt">FunctorOf</span> (<span class="ot">-&gt;</span>) (<span class="op">~~&gt;</span>) t</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b)</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> d)</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> (e <span class="ot">-&gt;</span> f)</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> t a c e</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> t b d f</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>triple f g h <span class="ot">=</span> a2b <span class="op">.</span> c2d <span class="op">.</span> <span class="fu">map</span> h</span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">Natural</span> c2d) <span class="ot">=</span> <span class="fu">map</span> g</span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">NatNat</span> (<span class="dt">Natural</span> a2b)) <span class="ot">=</span> <span class="fu">map</span> f</span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a><span class="ot">tripleExample ::</span> <span class="dt">Triple</span> <span class="dt">String</span> <span class="dt">String</span> <span class="dt">String</span></span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a>tripleExample <span class="ot">=</span> triple <span class="fu">show</span> <span class="fu">show</span> <span class="fu">show</span> (<span class="dt">Triple</span> (<span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span>) (<span class="dv">2</span><span class="ot"> ::</span> <span class="dt">Int</span>) (<span class="dv">3</span><span class="ot"> ::</span> <span class="dt">Int</span>))</span></code></pre></div>
<p>The pattern is pretty simple: - we need a <code>FunctorOf</code>
instance for every argument we want to map - for each such argument, we
need to use <code>-&gt;</code> for variant and <code>Op</code> for
contravariant arguments as the first argument to <code>FunctorOf</code>
- from right to left, we need to use increasing level of transforms to
map the type arguments (<code>-&gt;</code>, <code>~&gt;</code>,
<code>~~&gt;</code>, etc)</p>
<h2 id="what-about-invariants">What about invariants?</h2>
<p>We can define an instance for <code>Endo</code> using:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Iso</span> a b <span class="ot">=</span> <span class="dt">Iso</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> to   ::</span> a <span class="ot">-&gt;</span> b</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> from ::</span> b <span class="ot">-&gt;</span> a</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">FunctorOf</span> <span class="dt">Iso</span> (<span class="ot">-&gt;</span>) <span class="dt">Endo</span> <span class="kw">where</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="ot">  map ::</span> <span class="kw">forall</span> a b<span class="op">.</span> <span class="dt">Iso</span> a b <span class="ot">-&gt;</span> <span class="dt">Endo</span> a <span class="ot">-&gt;</span> <span class="dt">Endo</span> b</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">map</span> <span class="dt">Iso</span> { to, from } (<span class="dt">Endo</span> f) <span class="ot">=</span> <span class="dt">Endo</span> <span class="op">$</span> to <span class="op">.</span> f <span class="op">.</span> from</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="ot">endoExample ::</span> <span class="dt">Endo</span> <span class="dt">String</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>endoExample <span class="ot">=</span> <span class="fu">map</span> (<span class="dt">Iso</span> <span class="fu">show</span> <span class="fu">read</span>) (<span class="dt">Endo</span> (<span class="op">+</span> (<span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span>)))</span></code></pre></div>
<p>We can even go further:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">FunctorOf</span> (<span class="ot">-&gt;</span>) (<span class="ot">-&gt;</span>) f <span class="ot">=&gt;</span> <span class="dt">FunctorOf</span> <span class="dt">Iso</span> <span class="dt">Iso</span> f <span class="kw">where</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  map ::</span> <span class="dt">Iso</span> a b <span class="ot">-&gt;</span> <span class="dt">Iso</span> (f a) (f b)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">map</span> <span class="dt">Iso</span> { to, from } <span class="ot">=</span> <span class="dt">Iso</span> (<span class="fu">map</span> to) (<span class="fu">map</span> from)</span></code></pre></div>
<p>which is to say, given an isomorphism between <code>a</code> and
<code>b</code>, we can obtain an isomorphism between <code>f a</code>
and <code>f b</code>!</p>
<h2 id="future-work-ideas">Future work ideas</h2>
<p>I think this instance can be also used for proofs. For example, using
the <code>Refl</code> equality type:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> x <span class="op">:~:</span> y <span class="kw">where</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Refl</span><span class="ot"> ::</span> x <span class="op">:~:</span> x</span></code></pre></div>
<p>And this means we can write transitivity as:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">FunctorOf</span> (<span class="op">:~:</span>) (<span class="ot">-&gt;</span>) ((<span class="op">:~:</span>) x) <span class="kw">where</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  map ::</span> <span class="kw">forall</span> a b<span class="op">.</span> a <span class="op">:~:</span> b <span class="ot">-&gt;</span> x <span class="op">:~:</span> a <span class="ot">-&gt;</span> x <span class="op">:~:</span> b</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">map</span> <span class="dt">Refl</span> <span class="dt">Refl</span> <span class="ot">=</span> <span class="dt">Refl</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="ot">proof ::</span> <span class="dt">Int</span> <span class="op">:~:</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="op">:~:</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="op">:~:</span> <span class="dt">String</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>proof <span class="ot">=</span> <span class="fu">map</span></span></code></pre></div>
<p>Code is available <a
href="https://github.com/eviefp/functorof/blob/master/src/FunctorOf.hs">here</a>.</p>
<p>Another thing worth mentioning is the awesome upcoming <a
href="https://gitlab.haskell.org/kcsongor/ghc/tree/unsaturated_type_families">GHC
extension</a> (being worked on by <a
href="https://twitter.com/Lowert">Csongor Kiss</a>) which allows type
families to be partially applied. If you haven't <a
href="https://www.microsoft.com/en-us/research/publication/higher-order-type-level-programming-in-haskell/">read
the paper</a>, you should! Using this feature, one could do something
like:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">Id</span> a <span class="kw">where</span> <span class="dt">Id</span> x <span class="ot">=</span> x</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">FunctorOf</span> (<span class="ot">-&gt;</span>) (<span class="ot">-&gt;</span>) <span class="dt">Id</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">map</span> <span class="ot">=</span> (<span class="op">$</span>)</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="ot">idExample ::</span> <span class="dt">Bool</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>idExample <span class="ot">=</span> <span class="fu">map</span> (<span class="op">+</span><span class="dv">1</span>) <span class="dv">1</span> <span class="op">==</span> <span class="dv">2</span></span></code></pre></div>
<p>Please note I have not tested the above code; it was suggested by Tom
Harding (thanks again for the idea and reviewing!).</p>
<p>What other uses can you come up with?</p>]]></content>
  </entry>
  <entry>
      <title>Hire and Train Haskell Junior Developers</title>
      <link href="https://eevie.ro/posts/2019-12-30-junior-developers.html"/>
      <id>https://eevie.roposts/2019-12-30-junior-developers.html</id>
      <updated>2019-12-30T00:00:SZ</updated>
      <category term="personal"/>
      <category term="fp"/>
      <category term="haskell"/>
      <summary>A plea to senior developers and team leads</summary>
      <content type="html"><![CDATA[<p>I think the reason we don't have more people doing Haskell is we're
not actually hiring junior developers, and when we do, we don't set them
up for success by properly training them.</p>
<h2 id="introduction">Introduction</h2>
<p>This post was sparked by a few other posts in the Haskell world. They
are, to my knowledge, in chronological order:</p>
<ul>
<li>Michal Snoyman's <a
href="https://www.snoyman.com/blog/2019/11/boring-haskell-manifesto">Boring
Haskell Manifesto</a></li>
<li>Matt Parsons' <a
href="https://www.parsonsmatt.org/2019/12/26/write_junior_code.html">Write
Junior Code</a></li>
<li>Marco Sampellegrini's <a
href="https://alpacaaa.net/thoughts-on-haskell-2020/">My thoughts on
Haskell in 2020</a></li>
</ul>
<p>Snoyman's manifesto is a call to define a safe subset of the Haskell
language and common libraries, provide documentation, tutorials,
cookbooks, and continuously evolve, update, and help engineers use and
get "boring Haskell" adopted.</p>
<p>Parsons notes that Haskell has a hiring problem: there are few jobs,
and most of those are for senior developers. The reason for this is that
we over-indulge in fancy Haskell, making our code needlessly
complicated. If we wrote simple, junior-level Haskell, we would be able
to hire junior developers and have them be productive.</p>
<p>Sampellegrini's post points out a few key problems:</p>
<ul>
<li>there's a lot of extensions we need to keep track of, which makes
things hard</li>
<li>if an idea looks good on paper, it doesn't mean it's going to be
easy to maintain in the long run</li>
<li>inclusivity might be a problem: "I don't want a PhD to be a
requirement to work with Haskell"</li>
<li>they argue there's marginal benefit to fancy types/Haskell</li>
</ul>
<p>While I understand where all of these feelings are coming from, and I
agree to some of the ideas, I think they have their marks on the wrong
problem.</p>
<h2 id="the-real-problem">The Real Problem</h2>
<p>I think the real problem is that we are not putting up jobs for
junior devs. We're not even giving them a chance. And when we are, we
usually don't give them enough support (through training and making sure
they know who to ask, and that it's okay to do so) to succeed.</p>
<p>I'm really not sure why we're not hiring more junior developers. It
might be because seniors like to think that the code they are writing is
so complicated that a junior would take too long to be able to
understand, so they advise management that a junior cannot possibly be
productive. Maybe it's because they don't want to be bothered with
training junior devs, and they would rather just work on code instead?
Or maybe it's because management doesn't like seniors' time being
"wasted" on teaching junior devs?</p>
<p>Whatever the reason, I don't really think writing simpler code will
help much. If the on-boarding process is lacking, if the company culture
is not welcoming to junior devs, most of them will be set for failure
from the get-go, regardless of how fancy or simple the code is.</p>
<h2 id="junior-developers">Junior Developers</h2>
<p>What is a junior developer? For the purposes of this article, I will
define a Haskell junior developer as somebody who's able to confidently
use simple monads like <code>Maybe</code>, <code>Either e</code>,
<code>IO</code>, and the list monad. Ideally, they would also have a
crude understanding of monad transformers (but not necessarily
<code>mtl</code> as well). They are able to compose functions, reason
about ADTs, and, perhaps most importantly, are motivated to learn more
about Haskell and FP.</p>
<p>I currently work on two projects, both in Haskell. One of these
projects has two junior Haskell developers, and the other has one. I
will briefly go over the details of these projects as well as my
mentoring experience in order to establish a baseline.</p>
<p>I have not been working with Haskell for very long. I actually come
from OOP-land, and I have a lot of experience as a team lead. I have
hired, trained, and mentored a decent number of junior devs, most of
them in my OOP days, but also three of them recently, at the place I
currently work. For the past year and a half, I have been the main
developer in charge of training and making sure the junior devs are
productive.</p>
<p>Our codebases (you can <a
href="https://github.com/kframework/kore">see one of them here</a>) are
pretty complicated: besides the fact that they use notoriously complex
Haskell libraries such as <code>lens</code>, <code>servant</code>, and
<code>recursion-schemes</code>, the domain problem is pretty complicated
as well: we're essentially building an automated prover for a
rewrite-based executable semantic framework (the other project is a
pretty standard servant app, so not too much to go over there, although
it does use <code>lens</code>, <code>generic-lens</code>,
<code>persistent</code>/<code>esqueleto</code> and obviously
<code>servant</code>).</p>
<p>This prelude was needed because I can't really speak about junior
developers in general, but I can tell you about my experience with
on-boarding junior Haskell developers on our projects. However, before
that, I would like to add that the junior devs we hired were all either
senior year at the local university, or fresh graduates. They were
picked because they are all excited about FP, despite the fact that none
of them had any previous professional experience related to FP or
Haskell.</p>
<p>I am proud to say that all three junior devs are doing great. I
obviously can't take any significant part of the credit (they are all
very smart and hard working), but I think that there are a few things
that contributed to their success:</p>
<ul>
<li><strong>Kindness</strong> we've all gone through this. We're all
trying our best. Be kind and supportive. Praise them when they do a good
job. Encourage them to come up with ideas and to bring their ideas
forward.</li>
<li><strong>Confidence</strong> make sure they know it's okay to not
know things; there's a ton of things I don't know, and I make sure to be
loud about it. I also make sure to show them how I find the answers to
things I don't know. Of course, on top of literally telling them it's
okay to ask questions and not know stuff, even if it feels like it's
something they should know (there's no such thing, really: we all have
our blind spots).</li>
<li><strong>Support</strong> be there for them. We have daily meetings
and we make sure we know what everybody's up to. We make sure to ask
everybody if they're stuck or not, if they need help or more work.</li>
<li><strong>Training</strong> at least until they get comfortable, make
sure you go over the things that are "fancy" in the codebase. At the
very least, make sure you go over a few examples and show them how it
works. Make sure they understand. A few exercises where you work
together can be particularly useful as well.</li>
<li><strong>Clarity</strong> it is vitally important that tasks are as
crystal-clear as they can be. Make extra sure the tasks that junior devs
work on won't take them too far off the beaten path. Try to add
comments/more notes to these tasks: where to start, a very rough sketch
of the solution, how to test: anything can help.</li>
</ul>
<p>Only one of the three junior developers we hired was slightly
familiar with monad transformers at the time they were hired. The other
two were familiar with monads. We were able to get all three to
contribute PRs in less than a week after they started. Within 3 to 6
months, I noticed they started being able to complete tasks with little
supervision. One of them has been with us for little over an year, and
they are now able to take on complicated tasks (major refactoring,
learning new concepts, etc.) pretty much on their own.</p>
<h2 id="you-cant-possibly-teach-a-junior-x-in-y-days">You can't possibly
teach a junior X in Y days</h2>
<p>Since the subject is hot, I just saw a <a
href="https://twitter.com/jkachmar/status/1210977393197883393">tweet
from Joe Kachmar</a> which expresses the very idea I want to combat:
these things aren't THAT hard to teach. Of course a junior won't be able
to invent a new type of lenses, add a new layer to our application's
monad stack, or re-invent <code>generic-lens</code>, but nobody's
expecting them to.</p>
<p>After a week of training, I am sure a junior developer can add a new
REST API endpoint that is similar to one that's already in our
application. They can use getter lenses similar to the ones we already
have, but targeting different fields: they can re-use the existing
infrastructure to write "boring" code using whatever level of fancy
Haskell is already there as a guide.</p>
<p>And sure, sometimes they'll try something new and they'll get stuck
on a 20-page GHC type error. That's when they ask for help, because they
know it's okay not knowing things, and there's always someone available
that's happy to help (and they won't help by fixing the error for them,
but by guiding them into understanding and fixing the problem
themselves).</p>
<h2 id="why-not-both">Why not both?</h2>
<p>It's hard to focus on multiple solutions to the same problem. I am
also worried that the "Boring Haskell Manifesto" can even be harmful in
the long run.</p>
<p>Writing programs is really, really hard. Nothing focuses this feeling
better than writing pure FP, because it forces you to be clear, precise
and thorough about everything: you can't ignore <code>Nothing</code>s,
you can't discard <code>Left</code>s implicitly, you don't get to shove
things into a mutable global state.</p>
<p>Writing programs is really, really hard for everyone. It's not only
hard for junior developers. It's also hard for senior developers. We
haven't figured this out, we're not even close. We still have a terrible
story for errors: their composability is far from ideal. We still have a
lot of competing libraries for effects, and more seem to be coming.
There are a lot of libraries to be explored and discovered.</p>
<p>I do think that each team should be careful when adding language
extensions and choosing libraries for each project they work on. And I
do think the "fancyness" needs to be taken into account. As Parsons put
it on slack</p>
<blockquote>
<p>fanciness of your code should be gated on the size of your
mentoring/training budget if you value hiring juniors</p>
</blockquote>
<p>I totally agree, although I would also add that another important
aspect worth considering is the benefit of said fancyness.</p>
<p>There are many reasons one might want to stray off the beaten path.
Fancy type-level code might save you a ton of code duplication, or it
might add features that would otherwise make the code brittle or hard to
maintain. For some projects, this may be worth it.</p>
<p>I don't think a blessed set of libraries or extensions will help with
this. Which streaming library gets to be picked? Will it be
<code>conduit</code> over <code>pipes</code>? What about
<code>streaming</code>?</p>
<p>As I said, I think it's the wrong thing to focus on.</p>
<h2 id="conclusion">Conclusion</h2>
<p>We need to stop over-appreciating how hard it is to use "fancy"
libraries like <code>servant</code>, <code>lens</code> or
<code>recursion-schemes</code>. Give junior developers a fighting chance
and they will surprise you.</p>
<p>I don't think there's anything that makes our company's junior
developer success story non-reproducible anywhere else. Our local
university doesn't focus on FP or Haskell (they do have one course where
they teach Haskell, but that's pretty much it). We were actually forced
to take this route because there's no other companies that do Haskell
locally (as far as I know), so we can't just find Haskell developers
around.</p>
<p>I think this is reproducible anywhere, on pretty much any codebase.
We just need to open up junior positions, and give them the support they
need to succeed. Have you had some different experience? Is it hard to
find junior developers that are somewhat familiar with monads?</p>
<p>Go out there, convince your team that they're not actually living in
an ivory tower. It's not that hard, and we're not special for
understanding how to use these language extensions and libraries. We can
teach junior developers how to use them.</p>]]></content>
  </entry>
  <entry>
      <title>The Functor Family: Bifunctor</title>
      <link href="https://eevie.ro/posts/2020-01-02-bifunctor.html"/>
      <id>https://eevie.roposts/2020-01-02-bifunctor.html</id>
      <updated>2020-01-02T00:00:SZ</updated>
      <category term="haskell"/>
      <category term="functor"/>
      <summary>A look into bifunctors.</summary>
      <content type="html"><![CDATA[<p>This post assumes prior knowledge of - the <code>Functor</code> class
/ concept - the functor instance for <code>Either a</code>,
<code>(,) a</code> - basic kind knowledge, e.g. the difference between
<code>* -&gt; *</code> and <code>* -&gt; * -&gt; *</code></p>
<h2 id="why">Why</h2>
<p>In Haskell, functors can only be defined for types of kind
<code>* -&gt; *</code> like <code>Maybe a</code> or <code>[a]</code>.
Their instances allow us to use <code>fmap</code> (or
<code>&lt;$&gt;</code>) to go from <code>Maybe a</code> to
<code>Maybe b</code> using some <code>a -&gt; b</code>, like:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> <span class="fu">show</span> <span class="op">&lt;$&gt;</span> <span class="dt">Just</span> <span class="dv">1</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Just</span> <span class="st">&quot;1&quot;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> <span class="fu">show</span> <span class="op">&lt;$&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="dt">Nothing</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> <span class="fu">show</span> <span class="op">&lt;$&gt;</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>[<span class="st">&quot;1&quot;</span>, <span class="st">&quot;2&quot;</span>, <span class="st">&quot;3&quot;</span>]</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> <span class="fu">show</span> <span class="op">&lt;$&gt;</span> []</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>[]</span></code></pre></div>
<p>We can even define functor instances for higher kinded types, as long
as we fix type arguments until we get to <code>* -&gt; *</code>. For
example, <code>Either</code> has kind <code>* -&gt; * -&gt; *</code>,
but <code>Either e</code> has kind <code>* -&gt; *</code>. So that means
that we can have a functor instance for <code>Either e</code>, given
some type <code>e</code>. This might sound confusing at first, but all
it means is that the <code>e</code> cannot vary, so we can go from
<code>Either e a</code> to <code>Either e b</code> using some
<code>a -&gt; b</code>, but we cannot go from <code>Either e1 a</code>
to <code>Either e2 a</code> or <code>Either e2 b</code> even if we had
both <code>a -&gt; b</code> and <code>e1 -&gt; e2</code>. How would we
even pass two functions to <code>fmap</code>?</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> <span class="fu">show</span> <span class="op">&lt;$&gt;</span> <span class="dt">Right</span> <span class="dv">1</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Right</span> <span class="st">&quot;1&quot;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> <span class="fu">show</span> <span class="op">&lt;$&gt;</span> <span class="dt">Left</span> <span class="dt">True</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="dt">Left</span> <span class="dt">True</span></span></code></pre></div>
<p>In the first example, we go from <code>Either a Int</code> to
<code>Either a String</code> using
<code>show :: Int -&gt; String</code>. In the second example, we go from
<code>Either Bool a</code> to <code>Either Bool String</code>, where
<code>a</code> needs to have a <code>Show</code> instance.</p>
<p>But what if we want to go from <code>Either a x</code> to
<code>Either b x</code>, given some <code>a -&gt; b</code>?</p>
<p>Let's see how we could implement it ourselves:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mapLeft ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Either</span> a x <span class="ot">-&gt;</span> <span class="dt">Either</span> b x</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>mapLeft f (<span class="dt">Left</span> a) <span class="ot">=</span> <span class="dt">Left</span> (f a)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>mapLeft _ r        <span class="ot">=</span> r</span></code></pre></div>
<p>Since we are trying to map the <code>Left</code>, the interesting bit
is for that constructor: we apply <code>f</code> under
<code>Left</code>. Otherwise, we just leave the value as-is; a
<code>Right</code> value of type <code>x</code> (we could have written
<code>mapLeft _ (Right x) = Right x</code> and it would work the
same).</p>
<p>Here's a few warm-up exercises. The first uses typed holes to guide
you and clarify what's meant by "using <code>either</code>". The last
exercise can be a bit tricky. Look up what <code>Const</code> is and use
typed holes.</p>
<p><em>Exercise 1</em>: re-implement <code>mapLeft'</code> using
<code>either</code>:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mapLeft&#39; ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Either</span> a x <span class="ot">-&gt;</span> <span class="dt">Either</span> b x</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>mapLeft&#39; f e <span class="ot">=</span> <span class="fu">either</span> _leftCase _rightCase e</span></code></pre></div>
<p><em>Exercise 2</em>: implement <code>mapFirst</code>:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mapFirst ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a, x) <span class="ot">-&gt;</span> (b, x)</span></code></pre></div>
<p><em>Exercise 3</em>: implement <code>remapConst</code>:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Functor.Const</span> (<span class="dt">Const</span>(..))</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="ot">remapConst ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Const</span> a x <span class="ot">-&gt;</span> <span class="dt">Const</span> b x</span></code></pre></div>
<h2 id="how">How</h2>
<p>While we can implement <code>mapLeft</code>, <code>mapFirst</code>,
and <code>remapConst</code> manually, there is a pattern: some types of
kind <code>* -&gt; * -&gt; *</code> allow both their type arguments to
be mapped like a <code>Functor</code>, so we can define a new class:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Bifunctor</span> p <span class="kw">where</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">{-# MINIMAL bimap | first, second #-}</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  bimap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> p a c <span class="ot">-&gt;</span> p b d</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  first ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> p a c <span class="ot">-&gt;</span> p b c</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="ot">  second ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> p a b <span class="ot">-&gt;</span> p a c</span></code></pre></div>
<p><code>bimap</code> takes two functions and is able to map both
arguments in a type of kind <code>* -&gt; * -&gt; *</code>.
<code>first</code> is a lot like the functions we just defined manually.
<code>second</code> is always the same thing as <code>fmap</code>. This
class exists in <code>base</code>, under
<code>Data.Bifunctor</code>.</p>
<p><em>Exercise 4</em>: implement <code>bimap</code> in terms of
<code>first</code> and <code>second</code>.</p>
<p><em>Exercise 5</em>: implement <code>first</code> and
<code>second</code> in terms of <code>bimap</code>.</p>
<p><em>Exercise 6</em>: implement the <code>Bifunctor</code> instance
for <code>Either</code>:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Bifunctor</span> <span class="dt">Either</span> <span class="kw">where</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  bimap f _ (<span class="dt">Left</span> a)  <span class="ot">=</span> _leftCase</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  bimap _ g (<span class="dt">Right</span> b) <span class="ot">=</span> _rightCase</span></code></pre></div>
<p><em>Exercise 7</em>: Implement the <code>Bifunctor</code> instance
for tuples <code>(a, b)</code>.</p>
<p><em>Exercise 8</em>: Implement the <code>Bifunctor</code> instance
for <code>Const</code>.</p>
<p><em>Exercise 9</em>: Implement the <code>Bifunctor</code> instance
for <code>(a, b, c)</code>.</p>
<p><em>Exercise 10</em>: Find an example of a type with kind
<code>* -&gt; * -&gt; *</code> that cannot have a <code>Bifunctor</code>
instance.</p>
<p><em>Exercise 11</em>: Find an example of a type with kind
<code>* -&gt; * -&gt; *</code> which has a <code>Functor</code> instance
when you fix one type argument, but can't have a <code>Bifunctor</code>
instance.</p>]]></content>
  </entry>
  <entry>
      <title>The Functor Family: Contravariant</title>
      <link href="https://eevie.ro/posts/2020-01-07-contravariant.html"/>
      <id>https://eevie.roposts/2020-01-07-contravariant.html</id>
      <updated>2020-01-07T00:00:SZ</updated>
      <category term="haskell"/>
      <category term="functor"/>
      <summary>A look into contravariant functors.</summary>
      <content type="html"><![CDATA[<p>This post assumes prior knowledge of - the <code>Functor</code> class
/ concept - the functor instance for <code>(-&gt;) r</code></p>
<h2 id="why">Why</h2>
<p>Not all higher kinded types <code>* -&gt; *</code> can have a
<code>Functor</code> instance. While types like <code>Maybe a</code>,
<code>(x, a)</code>, <code>r -&gt; a</code>, <code>Either e a</code> and
<code>[a]</code> are <code>Functors</code> in <code>a</code>, there are
some types that cannot have a <code>Functor</code> instance. A good
example is <code>Predicate</code>:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Predicate</span> a <span class="ot">=</span> <span class="dt">Predicate</span> {<span class="ot"> getPredicate ::</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span> }</span></code></pre></div>
<p>We call this type a predicate in <code>a</code> because, given some
value of type <code>a</code> we can obtain a <code>True</code> or a
<code>False</code>. So, for example: - <code>Predicate (&gt; 10)</code>
is a predicate in <code>Int</code> which returns true if the number is
greater than 10, - <code>Predicate (== "hello")</code> is a predicate in
<code>String</code> which returns true if the string is equal to
<em>"hello"</em>, and - <code>Predicate not</code> is a predicate in
<code>Bool</code> which returns the negation of the boolean value it
receives.</p>
<p>We can try writing a <code>Functor</code> instance and see what we
can learn:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Predicate</span> <span class="kw">where</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Predicate</span> a <span class="ot">-&gt;</span> <span class="dt">Predicate</span> b</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> f (<span class="dt">Predicate</span> g) <span class="ot">=</span> </span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Predicate</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">$</span> \b <span class="ot">-&gt;</span> _welp</span></code></pre></div>
<p>As the type hole above would suggest, we need to return a
<code>Bool</code> value, and we have: - <code>b :: b</code> -
<code>f :: a -&gt; b</code> - <code>g :: a -&gt; Bool</code></p>
<p>There is no way we can combine these terms at all, let alone in such
a way as to obtain a <code>Bool</code> value. The only way we would be
able to obtain a <code>Bool</code> value is by calling <code>g</code>,
but for that, we need an <code>a</code> -- but all we have is a
<code>b</code>.</p>
<p>What if <code>f</code> was reversed, though? If we had
<code>f' :: b -&gt; a</code>, then we could apply <code>b</code> to it
<code>f' b :: a</code> and then pass it to <code>g</code> to get a
<code>Bool</code>. Let's write this function outside of the
<code>Functor</code> class:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mapPredicate ::</span> (b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Predicate</span> a <span class="ot">-&gt;</span> <span class="dt">Predicate</span> b</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>mapPredicate f (<span class="dt">Predicate</span> g) <span class="ot">=</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Predicate</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">$</span> \b <span class="ot">-&gt;</span> g (f b)</span></code></pre></div>
<p>This looks very weird, compared to <code>Functor</code>s, right? If
you want to go from <code>Predicate a</code> to
<code>Predicate b</code>, you need a <code>b -&gt; a</code>
function?</p>
<p><em>Exercise 1</em>: fill in the typed hole <code>_e1</code>:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">greaterThan10 ::</span> <span class="dt">Predicate</span> <span class="dt">Int</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>greaterThan10 <span class="ot">=</span> <span class="dt">Predicate</span> (<span class="op">&gt;</span> <span class="dv">10</span>)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="ot">exercise1 ::</span> <span class="dt">Predicate</span> <span class="dt">String</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>exercise1 <span class="ot">=</span> mapPredicate _e1 greaterThan10</span></code></pre></div>
<p><em>Exercise 2</em>: write <code>mapShowable</code> for the following
type:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Showable</span> a <span class="ot">=</span> <span class="dt">Showable</span> {<span class="ot"> getShowable ::</span> a <span class="ot">-&gt;</span> <span class="dt">String</span> }</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="ot">mapShowable ::</span> (b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Showable</span> a <span class="ot">-&gt;</span> <span class="dt">Showable</span> b</span></code></pre></div>
<p><em>Exercise 3</em>: Use <code>mapShowable</code> and
<code>showableInt</code> to implement <code>exercise3</code> such that
<code>getShowable exercise3 True</code> is <code>"1"</code> and
<code>getShowable exercise3 False</code> is <code>"2"</code>.</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">showableInt ::</span> <span class="dt">Showable</span> <span class="dt">Int</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>showableInt <span class="ot">=</span> <span class="dt">Showable</span> <span class="fu">show</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="ot">exercise3 ::</span> <span class="dt">Showable</span> <span class="dt">Bool</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>exercise3 <span class="ot">=</span></span></code></pre></div>
<h2 id="how">How</h2>
<p><code>Predicate</code> and <code>Showable</code> are very similar,
and types like them admit a <code>Contravariant</code> instance. Let's
start by looking at it:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Contravariant</span> f <span class="kw">where</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  contramap ::</span> (b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span></code></pre></div>
<p>The instances for <code>Predicate</code> and <code>Showable</code>
are trivial: they are exactly <code>mapPredicate</code> and
<code>mapShowable</code>. The difference between <code>Functor</code>
and <code>Contravariant</code> is exactly the function they receive: one
is "forward" and the other is "backward", and it's all about how the
data type is defined.</p>
<p>All <code>Functor</code> types have their type parameter
<code>a</code> in what we call a <em>positive</em> position. This
usually means there can be some <code>a</code> available in the type
(which is always the case for tuples, or sometimes the case for
<code>Maybe</code>, <code>Either</code> or <code>[]</code>). It can also
mean <em>we can obtain an <code>a</code></em>, like is the case for
<code>r -&gt; a</code>. Sure, we need some <code>r</code> to do that,
but we are able to obtain an <code>a</code> afterwards.</p>
<p>On the opposite side, <code>Contravariant</code> types have their
type parameter <code>a</code> in what we call a <em>negative</em>
position: they <em>need</em> to consume an <code>a</code> in order to
produce something else (a <code>Bool</code> or a <code>String</code> for
our examples).</p>
<p><em>Exercise 4</em>: Look at the following types and decide which can
have a <code>Functor</code> instance and which can have a
<code>Contravariant</code> instance. Write the instances down:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">T0</span> a <span class="ot">=</span> <span class="dt">T0</span> a <span class="dt">Int</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">T1</span> a <span class="ot">=</span> <span class="dt">T1</span> (a <span class="ot">-&gt;</span> <span class="dt">Int</span>)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">T2</span> a <span class="ot">=</span> <span class="dt">T2L</span> a <span class="op">|</span> <span class="dt">T2R</span> <span class="dt">Int</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">T3</span> a <span class="ot">=</span> <span class="dt">T3</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">T4</span> a <span class="ot">=</span> <span class="dt">T4L</span> a <span class="op">|</span> <span class="dt">T4R</span> a</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">T5</span> a <span class="ot">=</span> <span class="dt">T5L</span> (a <span class="ot">-&gt;</span> <span class="dt">Int</span>) <span class="op">|</span> <span class="dt">T5R</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</span></code></pre></div>
<p>As with <code>Functor</code>s, we can partially apply higher kinded
types to write a <code>Contravariant</code> instance. The most common
case is for the flipped version of <code>-&gt;</code>:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Op</span> a b <span class="ot">=</span> <span class="dt">Op</span> {<span class="ot"> getOp ::</span> b <span class="ot">-&gt;</span> a }</span></code></pre></div>
<p>While <code>a -&gt; b</code> has a <code>Functor</code> instance,
because the type is actually <code>(-&gt;) a b</code>, and
<code>b</code> is in a <em>positive</em> position, its flipped version
has a <code>Contravariant</code> instance.</p>
<p><em>Exercise 5</em>: Write the <code>Contravariant</code> instance
for <code>Op</code>:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Contravariant</span> (<span class="dt">Op</span> r) <span class="kw">where</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  contramap ::</span> (b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Op</span> r a <span class="ot">-&gt;</span> <span class="dt">Op</span> r b</span></code></pre></div>
<p><em>Exercise 6</em>: Write a <code>Contravariant</code> instance for
<code>Comparison</code>:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Comparison</span> a <span class="ot">=</span> <span class="dt">Comparison</span> {<span class="ot"> getComparison ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Ordering</span> }</span></code></pre></div>
<p><em>Exercise 7</em>: Can you think of a type that has both
<code>Functor</code> and <code>Contravariant</code> instances?</p>
<p><em>Exercise 8</em>: Can you think of a type that can't have a
<code>Functor</code> nor a <code>Contravariant</code> instance? These
types are called <code>Invariant</code> functors.</p>]]></content>
  </entry>
  <entry>
      <title>The Functor Family: Profunctor</title>
      <link href="https://eevie.ro/posts/2020-01-22-profunctor.html"/>
      <id>https://eevie.roposts/2020-01-22-profunctor.html</id>
      <updated>2020-01-22T00:00:SZ</updated>
      <category term="haskell"/>
      <category term="functor"/>
      <summary>A look into profunctors</summary>
      <content type="html"><![CDATA[<p>This post assumes prior knowledge of - <a
href="/contravariant">Contravariant</a> - <a
href="/bifunctor">Bifunctor</a></p>
<h2 id="why">Why</h2>
<p>We've seen how types of kind <code>* -&gt; *</code> can have
instances for <code>Functor</code> or <code>Contravariant</code>,
depending on the position of the type argument. We have also seen that
types of kind <code>* -&gt; * -&gt; *</code> can have
<code>Bifunctor</code> instances. These types are morally
<code>Functor</code> in both type arguments. We're left with one very
common type which we can't map both arguments of:
<code>a -&gt; b</code>. It does have a <code>Functor</code> instance for
<code>b</code>, but the <code>a</code> is morally
<code>Contravariant</code> (so it can't have a <code>Bifunctor</code>
instance). This is where <code>Profunctor</code>s come in.</p>
<p>Here's a list of a few common types with the instances they
allow:</p>
<table>
<thead>
<tr class="header">
<th>Type</th>
<th style="text-align: center;"><code>Functor</code></th>
<th style="text-align: center;"><code>Bifunctor</code></th>
<th style="text-align: center;"><code>Contravariant</code></th>
<th style="text-align: center;"><code>Profunctor</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>Maybe a</code></td>
<td style="text-align: center;">✓</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>[a]</code></td>
<td style="text-align: center;">✓</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>Either a b</code></td>
<td style="text-align: center;">✓</td>
<td style="text-align: center;">✓</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>(a,b)</code></td>
<td style="text-align: center;">✓</td>
<td style="text-align: center;">✓</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>Const a b</code></td>
<td style="text-align: center;">✓</td>
<td style="text-align: center;">✓</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>Predicate a</code></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">✓</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>a -&gt; b</code></td>
<td style="text-align: center;">✓</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">✓</td>
</tr>
</tbody>
</table>
<p>Although there are some exceptions, you will usually see
<code>Contravariant</code> or <code>Profunctor</code> instances over
function types. <code>Predicate</code> itself is a newtype over
<code>a -&gt; Bool</code>, and so are most types with these
instances.</p>
<p>Let's take a closer look at <code>a -&gt; b</code>. We can easily map
over the <code>b</code>, but what about the <code>a</code>? For example,
given <code>showInt :: Int -&gt; String</code>, what do we need to
convert this function to <code>showBool :: Bool -&gt; String</code>:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">showInt</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">showInt</span> <span class="ot">=</span> <span class="fu">show</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="ot">showBool ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>showBool b <span class="ot">=</span> _help</span></code></pre></div>
<p>We would have access to: - <code>showInt :: Int -&gt; String</code> -
<code>b :: Bool</code> and we want to use <code>showInt</code>, so we
would need a way to pass <code>b</code> to it, which means we'd need a
function <code>f :: Bool -&gt; Int</code> and then <code>_help</code>
would become <code>showInt (f b)</code>.</p>
<p>But if we take a step back, in order to go from
<code>Int -&gt; String</code> to <code>Bool -&gt; String</code>, we need
<code>Bool -&gt; Int</code>, which is exactly the
<code>Contravariant</code> way of mapping types.</p>
<p><em>Exercise 1</em>: Implement a <code>mapInput</code> function
like:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mapInput ::</span> (input <span class="ot">-&gt;</span> out) <span class="ot">-&gt;</span> (newInput <span class="ot">-&gt;</span> input) <span class="ot">-&gt;</span> (newInput <span class="ot">-&gt;</span> out)</span></code></pre></div>
<p>Extra credit: try a pointfree implementation as
<code>mapInput = _</code>.</p>
<p><em>Exercise 2</em>: Try to guess how the <code>Profunctor</code>
class looks like. Look at <code>Functor</code>,
<code>Contravariant</code>, and <code>Bifunctor</code> for
inspiration.</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Profunctor</span> p <span class="kw">where</span></span></code></pre></div>
<p><em>Exercise 3</em>: Implement an instance for <code>-&gt;</code> for
your <code>Profunctor</code> class.</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Profunctor</span> (<span class="ot">-&gt;</span>) <span class="kw">where</span></span></code></pre></div>
<h2 id="how">How</h2>
<p>Unlike <code>Functor</code>, <code>Contravariant</code>, and
<code>Bifunctor</code>, the <code>Profunctor</code> class is not in
<code>base</code>/<code>Prelude</code>. You will need to bring in a
package like <code>profunctors</code> to access it.</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Profunctor</span> p <span class="kw">where</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">{-# MINIMAL dimap | lmap, rmap #-}</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  dimap ::</span> (c <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> p a b <span class="ot">-&gt;</span> p c d</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  lmap ::</span> (c <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> p a b <span class="ot">-&gt;</span> p c b</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="ot">  rmap ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> p a b <span class="ot">-&gt;</span> p a c</span></code></pre></div>
<p><code>dimap</code> takes two functions and is able to map both
arguments in a type of kind <code>* -&gt; * -&gt; *</code>.
<code>lmap</code> is like <code>mapInput</code>. <code>second</code> is
always the same thing as <code>fmap</code>.</p>
<p><em>Exercise 4</em>: implement <code>dimap</code> in terms of
<code>lmap</code> and <code>rmap</code>.</p>
<p><em>Exercise 5</em>: implement <code>lmap</code> and
<code>rmap</code> in terms of <code>dimap</code>.</p>
<p><em>Exercise 6</em>: implement the <code>Profunctor</code> instance
for <code>-&gt;</code>:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Profunctor</span> (<span class="ot">-&gt;</span>) <span class="kw">where</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- your pick: dimap or lmap and rmap</span></span></code></pre></div>
<p><em>Exercise 7</em>: (hard) implement the <code>Profunctor</code>
instance for:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Sum</span> f g a b</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="dt">L</span> (f a b)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">R</span> (g a b)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Profunctor</span> f, <span class="dt">Profunctor</span> g) <span class="ot">=&gt;</span> <span class="dt">Profunctor</span> (<span class="dt">Sum</span> f g) <span class="kw">where</span></span></code></pre></div>
<p><em>Exercise 8</em>: (hard) implement the <code>Profunctor</code>
instance for:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Product</span> f g a b <span class="ot">=</span> <span class="dt">Product</span> (f a b, g a b)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Profunctor</span> f, <span class="dt">Profunctor</span> g) <span class="ot">=&gt;</span> <span class="dt">Profunctor</span> (<span class="dt">Product</span> f g) <span class="kw">where</span></span></code></pre></div>]]></content>
  </entry>
  <entry>
      <title>&#39;Always Knew&#39;</title>
      <link href="https://eevie.ro/posts/2022-01-01-always-knew.html"/>
      <id>https://eevie.roposts/2022-01-01-always-knew.html</id>
      <updated>2022-01-01T00:00:SZ</updated>
      <category term="personal"/>
      <summary>something something trans and programmer</summary>
      <content type="html"><![CDATA[<p>When I started questioning my gender, I didn't know much about what
it means to be transgender, so I started doing some research. And I
mostly found stories from folks saying they "always knew" since a very
young age that they were a different gender than the one assigned at
birth. And it's great that these stories are out there, but these
experiences are different from what I experienced. And I found very few
stories similar to mine.</p>
<p>I know I'm not special, it's just that the "always knew" stories seem
to draw more attention. I know a lot of folks who did not always
know.</p>
<p>I had no idea. Literally none. Despite being relatively well informed
about trans rights and experiences, I was totally oblivious. And the
lack of similar stories delayed and made my self-acceptance harder.</p>
<p>So here I am sharing my story, in hopes that someone will find this
useful.</p>
<h2 id="my-story">My story</h2>
<p>It was almost a year ago. I was 36, had a wife, a 2 year old
daughter, a good job... and something was missing. I didn't even
consciously think about it, I always blamed some other factors (it's
normal to be tired/stressed with a baby, it's just the pandemic, it's
this or that). I was never able to conjure the question "Am I
transgender?".</p>
<p>And yet, a lot of things were off. I always felt weird or different.
I never quite fit in like the others. It wasn't extreme, and it wasn't
obvious. It was easy to read as something else, such as introversion,
shyness, being a bit weird or closed off, etc.</p>
<p>It was my ex-wife who asked me, one evening, as if it was nothing,
whether I am trans (she recalls asking me whether I was in some way part
of the LGBTQ+ community, so maybe I just heard what I needed to hear?
not sure).</p>
<p>And my initial reaction was, "Of course I'm not!". I would know,
right? I'm 36. There's no way I would not know this about myself. I
could have <a
href="https://twitter.com/NightlingBug/status/1162044162033762304">passed
a polygraph test</a> saying I am a cis man.</p>
<p>I pushed the thought away, but it came back a few weeks later. What
if I am transgender? Those first few days are very fuzzy. I started
looking up as much as I could online.</p>
<p>One thing which stood out is something you'll find a lot online:
"most cis people don't question their gender". And that sounds
reasonable enough to at least give me the fuel I needed to dig
deeper.</p>
<p>The next thing I remember is finding out about FaceApp and trying it
out. I didn't even have a selfie I could use, so I had to take a selfie.
I proceeded to launch the app, play with the sliders and hit the gender
swap button. AND HOLY FUCK DID MY JAW DROP. Could I actually be
attractive?</p>
<p>That thought alone would ring all the alarm bells now, but hindsight
doesn't help past me.</p>
<p>I have no idea how I managed to sleep that night, but it wasn't
great. The next day, I started reading about HRT (Hormone Replacement
Therapy) and surgeries because that's what a lot of the discourse is, at
least what you can easily find through searching. And it's such a shame,
because there's an implicit idea being thrown, which is, medically
transitioning is mandatory or implicit.</p>
<h2 id="am-i-really-trans">Am I really trans?</h2>
<p>There's really no test, question, or anything that can tell someone
whether they are transgender or not. Having said that, there seem to be
some thoughts, experiences, things in common for a lot of us. None of
them are exclusive to transgender folks, but reading them helped me
realise some of the things I've been repressing.</p>
<p>Keep in mind you <a
href="https://twitter.com/NightlingBug/status/1162035381946245121">live
in your body 24/7</a>. And we humans are really good at adapting to
adverse situations. We learn coping mechanisms, we do mental gymnastics,
we make the best out of what we have.</p>
<h3 id="body">Body</h3>
<p>I have always hated my body. I would hate looking in the mirror or
having my picture taken. I would not take care of it at all, dress in
baggy clothes, etc. In retrospect, it turns out I was in the wrong kind
of body.</p>
<p>I hated having to dress up for occasions, so I hated them and made a
discourse on how they are silly: a waste of time.</p>
<p>Actually, I was even a little bit proud of my lack of vanity. I
didn't waste time on grooming, picking clothes or taking care of
myself.</p>
<p>I almost always had long hair and I hated when I cut it short (only
did it a couple of times and hated it every time).</p>
<p>I had what I later found out is sometimes called a "dysphoria beard".
It's when you don't groom or shave your beard because you hate it, and
having to tend to it daily/on a regular basis is annoying, painful,
something you avoid.</p>
<p>I almost always chose female avatars in games. My mental gymnastics
reasoning was, I'd rather look at a female if I was going to spend hours
playing, but at least some of them were first person so that was not
it.</p>
<h3 id="feelings">Feelings</h3>
<p>I used to repress my feelings a lot. I very rarely cried, or had any
strong (positive) emotions, especially when it came to me and my life.
In retrospect, it is fairly obvious it was a coping mechanism from
repressed thoughts, but I did not realise what it was until
recently.</p>
<p>I did, however, cry a lot at movies (or other kinds of media). I
would always cry at <a
href="https://www.youtube.com/watch?v=TVcLIfSC4OE">I'll Make A Man Out
Of You</a>. I had no idea why it made me cry, but now it's pretty clear
to me that it's because it's about a woman being forced to pretend she's
a man.</p>
<p>There were also a lot of things that were not obvious until I read
them. For example, a sense of <a
href="https://zinniajones.medium.com/depersonalization-in-gender-dysphoria-widespread-and-widely-unrecognized-baaac395bcb0">detachment
or enstrangement</a> from my own feelings and body. Feeling I am going
through the motions of participating in my day-to-day life and observing
rather than actively experiencing and taking part.</p>
<p>It's worth mentioning that once I started accepting, being more
active in queer spaces, and reflecting on my past, I started remembering
a lot of other things. For example, how back in my teens I had this
burning wish to wake up as a girl and experience how that feels like, at
least for a while. However, I brushed that off and figured, surely,
everybody is curious and would like to experience being the "other
gender".</p>
<h3 id="social">Social</h3>
<p>I've always had very few male friends, and avoided alpha male/overly
masculine presenting type of people. On the other hand, I've always had
female friends, and could easily open up to them.</p>
<p>I've always defended and talked about trans issues in conversations
with my family and group of friends. I always found it weird people had
a hard time understanding the difference between sex, gender, and sexual
orientation, all the while it was easy for me to understand.</p>
<h3 id="positivity">Positivity</h3>
<p>There were some positive milestones as well. The first time I saw
"her" in the mirror (that's how I, and a lot of transgender folks say
when we mean "I saw myself in the mirror and I thought I looked like the
gender I feel") was incredible.</p>
<p>It almost always felt amazing to try gendered stuff like clothes,
make-up, nail polish, etc, for the first time. However, they relatively
quickly become the norm (and that's awesome too!).</p>
<p>It's worth mentioning that, on most occasions when trying something
from the list above, I got an erection. That is quite common the first
(few) time(s). It doesn't mean it's "just a fetish" or that there's
anything wrong with you.</p>
<h3 id="dysphoria">Dysphoria</h3>
<p>I recall the first time I felt dysphoria. It was about a few weeks
after I started questioning. I was doing the dishes, while thinking
about random things. And then I looked at my hands and I noticed the
hair on my arms, and I totally freaked out. I wanted to pluck it out
hair by hair, burn it, do ANYTHING to remove it RIGHT THEN.</p>
<p>I was able to stop and relax, but it was pretty awful. And then a
funny thing happened: I realised I just experienced gender dysphoria.
And that made me very happy, because it means an extra data point, more
validation that I am indeed transgender.</p>
<p>I don't experience genital dysphoria, and as such, I am not planning
to have THE (or breast augmentation/facial feminization) surgery. I
honestly don't care much about what kind of floppy bits I (or my
partner) has. And while I haven't experienced all possible combinations,
I am fairly certain they're all fun and interesting.</p>
<h3 id="gatekeeping">Gatekeeping</h3>
<p>There are a lot of terrible guides out there for psychiatrists
gatepeeking us from the medical care we need. There are places where you
don't qualify as transgender unless you suffer from gender dysphoria, or
you need to socially live as the gender you identify as for some time
(ranges from 6 months to 2 years from what I've heard) before you can
get diagnosed and get the treatment you need.</p>
<p>It took me less than a couple of months to be certain enough to want
to begin medically transitioning, and I only had a couple of intense
dysphoric events.</p>
<h2 id="how-i-feel-now">How I feel now</h2>
<p>All of these thoughts and lists of reasons and trans checklists
already seem ancient, despite being less than a year old.</p>
<p>I went from taking half an hour of explaining to people that I am
trans, and how I prefer feminine pronouns, and what that means and
essentially apologising for being a burdain, to just waving and saying
my name.</p>
<p>Now I know I don't need a reason (let alone multiple reasons) to be a
woman. I just feel like one, and I enjoy being seen as one. And that is
enough.</p>
<p>I've learned to take care of my body, to use make-up, to dress up, to
walk in high heels. I am now able to look in the mirror and usually like
what I see. I even have a few pictures of myself that I love and think I
look hot!</p>
<p>I'm not less of a woman for being attracted to women. I'm not less of
a woman for having a penis, a beard (or a shadow), or a deep voice. And
whether I decide to do something about any of the above is entirely my
own personal decision (which may be influenced by dysphoria,
preferences, etc.).</p>
<p>I used to not be able to go out or turn on my webcam unless I shaved,
dressed girly, wore make-up and all of that. Nowdays, none of that
bothers me much at all. I think it's due to multiple reasons, such as
feeling more comfortable with myself, my gender expression, and trusting
the people around me more.</p>
<p>On that subject, I did lose some friends, and grew apart from most of
my family. And that's on them. I tried my best, I gave them all I could,
but it shouldn't all be on me. They shouldn't make me feel as if
something is wrong with me. They shouldn't make me feel as if I had some
reason to be ashamed or apologise. They should be happy that I found
myself and that I am happy.</p>
<p>I don't hate them or feel resentment, and if they ever want to get
back in touch or try to repair the relationship, I'd be happy to try.
I'm usually also happy to educate, but I am rarely in the mood to debate
the validity of my identity.</p>
<p>I feel happy, I feel I am slowly finding out how I like to express my
gender. And while I am fundamentally the same person, I am finally
allowing myself to live, be happy, and enjoy life, and even love myself
a tiny bit.</p>
<h2 id="closing-thoughts">Closing thoughts</h2>
<p>I said that one of the things that helped me was finding this meme
about how most cis people don't question their gender. And I wish that
wasn't true.</p>
<p>I think everybody should question their gender. Sure, most will find
they are aligned with their assigned gender at birth, but they would
learn a lot in the process. They would have a better understanding of
their gender expression, have a better understanding of the other
genders experiences, and probably have a little bit more empathy towards
transgender people.</p>
<p>What would my advice be? Just try stuff out. I'm not going to pretend
I understand the transmasc experience, but if you're questioning whether
you might be transfemme: get your nails done, put on some make-up, try
out some feminine clothes. See if it feels right. Try a feminine name
for size, ask some people to use feminine pronouns when addressing you.
I think that's the only way to really find out.</p>]]></content>
  </entry>
  <entry>
      <title>How I Nix</title>
      <link href="https://eevie.ro/posts/2022-01-24-how-i-nix.html"/>
      <id>https://eevie.roposts/2022-01-24-how-i-nix.html</id>
      <updated>2022-01-24T00:00:SZ</updated>
      <category term="nix"/>
      <summary>My system configuration and dotfiles</summary>
      <content type="html"><![CDATA[<p>The earliest <a
href="https://github.com/eviefp/dotfiles/commit/4879a6e3f9d915e1498f38412fab472f562b3a08">commit</a>
I could find in my dotfiles repository of me using NixOS is 5th of
February, 2020. So I have been running/using NixOS for about that long,
which is not a lot. I definitely do not consider myself an expert. That
being said, I put in a lot of hours into my NixOS setup. I enjoy
everything being neat and tidy.</p>
<p>I will try to explain how this works from the perspective of someone
who is familiar with running Linux, but has little to no Nix/NixOS
experience. If you're already familiar with NixOS and home-manager and
just want to see my setup, the <a
href="https://github.com/eviefp/dotfiles#readme">dotfiles repository
README</a> might be enough.</p>
<h2 id="what-is-nix">What is Nix?</h2>
<p><code>Nix</code> is a functional programming language mainly used to
power <code>nix</code>, the package manager.</p>
<p><code>NixOS</code> uses the <code>nix</code> package manager, as well
as <code>nix</code> the programming language to define and manage an
entire Linux distribution, system settings, packages, etc.</p>
<h2 id="why-nixos">Why NixOS</h2>
<p>The most important thing for me is being able to find the exact
versions of everything on my system with reasonable certainty, as well
as the ability to update them. Of course, some of it might involve some
digging, but I don't mind that.</p>
<p>Secondly, I can easily reproduce any of my systems, entirely. My
systems run the same version of everything. I've had to reinstall. I
accidentally <code>rm -rf</code>ed parts of my system. I could trivially
get everything system or configuration-related back.</p>
<p>It also makes it easy to have different versions of various software
installed (and even eaiser through the use of <code>nix-shell</code> and
<code>direnv</code> / <code>lorri</code>).</p>
<p>Another big plus for me is the ease of system configuration. I am not
an expert in running Linux systems, and having the most common system
options browsable through <a
href="https://search.nixos.org/options">nixopts</a> makes it a lot
easier.</p>
<p>It also makes trying out new things very easy (as long as it's
already packaged by somebody else), including trying out new system
settings. You can also trivially revert your system to a previous
configuration.</p>
<p>However, with all the good, there's also downsides. The main problem
is that it's definitley not mainstream so if you don't use relatively
popular hardware, software, etc., you might end up having to dig quite a
bit.</p>
<p>Another downside is that since <code>NixOS</code> doesn't install
anything globally, you will not be able to run pretty much any binary
without nixifying it first, which at a minimum means patching its
dynamic library paths. The good news is that there's already tools to do
that. But it will still not work out of the box.</p>
<p>You can read a bit more about how <code>nix</code> and
<code>NixOS</code> work over on the official <a
href="https://nixos.org/guides/how-nix-works.html">NixOS how it works
page</a>.</p>
<h2 id="trying-it-out">Trying it out</h2>
<p>When I tried <code>nix</code> out, I wanted to get a good feel for
it, so I jumped straight in by buying an extra disk and installed NixOS
on it. It was fairly painless to set everything up, so a few months
later I concluded the experiment was successful and migrated it to my
main disk.</p>
<p>That being said, you can take it slower by installing
<code>nix</code> the <a
href="https://nixos.org/download.html#download-nix">package
manager</a>.</p>
<p>Another option is installing a <a
href="https://nixos.org/download.html#nixos-virtualbox">NixOS virtual
machine</a>.</p>
<p>This post details the first option (although you can easily use the
same ideas in a NixOS VM).</p>
<h2 id="installing-nixos">Installing NixOS</h2>
<p>The <a
href="https://nixos.org/manual/nixos/stable/#sec-installation">NixOS
installation guide</a> is quite good and should get you up and
running.</p>
<p>Make sure you read the <a
href="https://nixos.org/manual/nixos/stable/index.html#sec-x11">X Window
System</a> section of the configuration and setup a minimal X server
unless you are 100% comfortable using the console after the first
reboot.</p>
<p>I highly recommend you add a few of the things you need to your
initial list of programs in your install
<code>configuration.nix</code>:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Uncomment this if needed (you&#39;ll know).</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co"># nixpkgs.config.allowUnfree = true;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>environment.systemPackages = <span class="op">[</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  <span class="co"># or &#39;emacs&#39; or &#39;vscode&#39; or whichever editor you prefer</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  <span class="co"># just make sure you have one</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  pkgs.vim</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  <span class="co"># or &#39;chromium&#39; or &#39;google-chrome&#39; or whatever</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  pkgs.firefox</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="op">]</span>;</span></code></pre></div>
<p>You can lookup more programs that you might need over on the <a
href="https://search.nixos.org/packages">NixOS package search</a>.</p>
<p>Note: if a package is named <code>haskellPackages.ghcid</code>, then
you'll need to add <code>pkgs.haskellPackages.ghcid</code>.</p>
<h2 id="nix-channels-nix-env-and-why-i-avoid-them">Nix Channels,
nix-env, and why I avoid them</h2>
<p>Nix channels are a way to manage your system and globally installed
programs (via <code>nix-env</code>). How this works is essentially, you
subscribe to a channel (say, <code>nixos-21.11</code>) and then you can
update to the latest released patch by doing
<code>nix-channel --update</code>. The problem with that is that it's
not easily reversible. Also, <code>nix-env</code> isn't a very pleasant
package management experience.</p>
<p>The package search I mentioned earlier shows install instructions
using <code>nix-env</code>. I strongly recommend against that.</p>
<p>Luckily, there's a pretty good alternative: we can use <a
href="https://github.com/nmattia/niv">niv</a> to point to specific
commits in the nixpkgs repository. Those are essentially the same as
channels, but we get it written down in a file we control.</p>
<p>We can also have multiple versions pinned for specific software if we
need to.</p>
<h2 id="pinning-your-nixos-configuration-and-system-packages">Pinning
your NixOS configuration and system packages</h2>
<p>There's a few things we need to do:</p>
<ol>
<li>Setup a pin for <code>nixpkgs</code></li>
<li>Create a <code>shell.nix</code> file to make use of said pin</li>
<li>Create a <code>configuration.nix</code> file</li>
<li>Set everything up</li>
</ol>
<h3 id="pinning-nixpkgs">Pinning nixpkgs</h3>
<p>Create a new directory, grab niv and init the repository.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mkdir</span> nixfiles</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="bu">cd</span> nixfiles</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="ex">nix-shell</span> <span class="at">-p</span> niv</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="ex">niv</span> init</span></code></pre></div>
<p>You should now have a <code>nix</code> directory with two files:
<code>sources.nix</code> and <code>sources.json</code>. The former
contains basic nix code to load everything in the json file, while the
latter contains the repository data including the commit SHA each
dependency is currently pinned. If you put this file under version
control, you can easily revert to a previously known working
configuration.</p>
<p>And now run <code>niv show</code>. You should see two dependencies:
<code>niv</code> itself and <code>nixpkgs</code>. If
<code>nixpkgs</code> is pinned to <code>NixOS/nixpkgs-channels</code>,
it means you have an older version of <code>niv</code> and you need to
update this dependency by running</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ex">niv</span> drop nixpkgs</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="ex">niv</span> add nixos/nixpkgs <span class="at">--branch</span> nixos-21.11</span></code></pre></div>
<p>Note: you should probably use the latest released version available
on the <a href="https://github.com/NixOS/nixpkgs">nixpkgs repository</a>
instead of <code>nixos-21.11</code>.</p>
<h3 id="creating-a-shellnix-file">Creating a shell.nix file</h3>
<p>Next, we need to create a <code>shell.nix</code> file:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Import pinned repositories</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="va">sources</span> <span class="op">=</span> <span class="bu">import</span> <span class="ss">./nix/sources.nix</span><span class="op">;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Grab nixpkgs from there</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  <span class="va">nixpkgs</span> <span class="op">=</span> <span class="bu">import</span> sources.nixpkgs <span class="op">{</span> <span class="va">config</span>.<span class="va">allowUnfree</span> <span class="op">=</span> <span class="cn">true</span><span class="op">;</span> <span class="op">};</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a shell</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>nixpkgs.mkShell <span class="op">{</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>  <span class="va">nativeBuildInputs</span> <span class="op">=</span> <span class="op">[</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    nixpkgs.niv <span class="co"># grab the latest version of niv</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">];</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Force this nixpkgs to be available for commands such as</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>  <span class="co"># nix-shell -p &lt;package&gt;</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>  <span class="va">NIX_PATH</span> <span class="op">=</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;nixpkgs=</span><span class="sc">${</span>sources.nixpkgs<span class="sc">}</span><span class="st">:nixos-config=/etc/nixos/configuration.nix&quot;</span><span class="op">;</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>We can now launch a shell by running <code>nix-shell</code>. You can
check that it's working by checking your <code>NIX_PATH</code>
value:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ex">nix-shell</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="bu">echo</span> <span class="va">$NIX_PATH</span></span></code></pre></div>
<p>And you should see something like
<code>nixpkgs=/nix/store/ynv2jfdrw7arx3q4xjir7mn0j2w97pcy-source:nixos-config=/etc/nixos/configuration.nix</code>.</p>
<h3 id="system-configuration-file">System configuration file</h3>
<p>The easiest way to get started is to copy the nixfiles that you used
during the install phase over. They should be a good place to start:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="fu">cp</span> /etc/nixos/<span class="pp">*</span>.nix .</span></code></pre></div>
<p>Without any additional changes, we can now rebuild everything using
the new pin.</p>
<h3 id="setting-everything-up">Setting everything up</h3>
<p>In order for all this to work, we'll need to remove the files from
<code>/etc/nixos</code> and symlink to their copies:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sudo</span> rm /etc/nixos/<span class="pp">*</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="fu">sudo</span> ln <span class="at">-s</span> <span class="va">$PWD</span>/configuration.nix /etc/nixos/</span></code></pre></div>
<p>And now you are ready to switch to this config using the freshly
created pin:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ex">nix-shell</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="fu">sudo</span> <span class="at">--preserve-env</span> nixos-rebuild switch</span></code></pre></div>
<p>You don't need to re-enter the <code>nix-shell</code> if you have not
left the one we entered when verifying the <code>NIX_PATH</code>.</p>
<p>That's it! You can now update to the latest commit of the current
branch by running <code>niv update</code>. You can also switch branches
to a different NixOS release. Note that you should also update your
<code>configuration.nix</code>'s <code>system.stateVersion</code>
accordingly.</p>
<h2 id="setting-up-home-manager">Setting up home-manager</h2>
<p>The above is great for setting up your system, but it's not ideal for
config files and user programs. For this, <a
href="https://github.com/nix-community/home-manager">home-manager</a> is
the better choice.</p>
<p>First off, it does not need root (<code>sudo</code>) rights to change
the settings. Secondly, it has a few more options for some programs, and
some helpers around things like user services, emails, etc.</p>
<p>In order to get started, we'll:</p>
<ol>
<li>Add <code>home-manager</code> to our pins</li>
<li>Update our <code>shell.nix</code> accordingly</li>
<li>Create a basic <code>home.nix</code> file to start us off</li>
</ol>
<h3 id="pin-home-manager">Pin home-manager</h3>
<p>We'll start in the same directory where we created the
<code>shell.nix</code> file previously, and add a pin for
<code>home-manager</code>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ex">niv</span> add home-manager <span class="at">--branch</span> release-21.11</span></code></pre></div>
<p>Make sure the branch release matches your NixOS version!</p>
<h3 id="update-shell-file">Update shell file</h3>
<p>Next, we need to reference this in our <code>shell.nix</code>:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Import pinned repositories</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  <span class="va">sources</span> <span class="op">=</span> <span class="bu">import</span> <span class="ss">./nix/sources.nix</span><span class="op">;</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Grab nixpkgs from there</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  <span class="va">nixpkgs</span> <span class="op">=</span> <span class="bu">import</span> sources.nixpkgs <span class="op">{</span> <span class="va">config</span>.<span class="va">allowUnfree</span> <span class="op">=</span> <span class="cn">true</span><span class="op">;</span> <span class="op">};</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Grab home-manager as well</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>  <span class="va">home-manager</span> <span class="op">=</span> <span class="bu">import</span> sources.home<span class="op">-</span>manager <span class="op">{</span> <span class="op">};</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a shell</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>nixpkgs.mkShell <span class="op">{</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>  <span class="va">nativeBuildInputs</span> <span class="op">=</span> <span class="op">[</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>    nixpkgs.niv <span class="co"># grab the latest version of niv</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">];</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>  <span class="va">NIX_PATH</span> <span class="op">=</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;nixpkgs=</span><span class="sc">${</span>sources.nixpkgs<span class="sc">}</span><span class="st">:home-manager=</span><span class="sc">${</span>sources.home<span class="op">-</span>manager<span class="sc">}</span><span class="st">:nixos-config=/etc/nixos/configuration.nix&quot;</span><span class="op">;</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Note that we added <code>home-manager</code> to our
<code>NIX_PATH</code>. That's all we need to do for now.</p>
<h3 id="create-our-first-home-nix-file">Create our first home nix
file</h3>
<p>Let's create a new <code>home.nix</code> file. I added some ideas of
things you might want. Feel free to remove anything you don't care
about:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode nix"><code class="sourceCode nix"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  <span class="va">home</span>.<span class="va">packages</span> <span class="op">=</span> <span class="op">[</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    pkgs.killall</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    pkgs.ripgrep</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    pkgs.wget</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    pkgs.unzip</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    pkgs.zip</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">];</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>  <span class="va">home</span>.<span class="va">file</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># If you keep these, you&#39;ll have to move the files here first.</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;</span>.config/nvim/init.vim<span class="st">&quot;</span>.<span class="va">source</span> <span class="op">=</span> <span class="ss">./init.vim</span><span class="op">;</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;.config/nvim/coc-settings.json&quot;</span>.<span class="va">source</span> <span class="op">=</span> <span class="ss">./coc-settings.json</span><span class="op">;</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">};</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>  <span class="va">programs</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Better &#39;cat&#39;</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>    <span class="va">bat</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>      <span class="va">enable</span> <span class="op">=</span> <span class="cn">true</span><span class="op">;</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>      <span class="va">config</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>        <span class="va">theme</span> <span class="op">=</span> <span class="st">&quot;TwoDark&quot;</span><span class="op">;</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>        <span class="va">pager</span> <span class="op">=</span> <span class="st">&quot;less -FR&quot;</span><span class="op">;</span></span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>      <span class="op">};</span></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Really useful for auto-running &#39;shell.nix&#39;, see also: lorri</span></span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a>    <span class="va">direnv</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>      <span class="va">enable</span> <span class="op">=</span> <span class="cn">true</span><span class="op">;</span></span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a>      <span class="va">enableBashIntegration</span> <span class="op">=</span> <span class="cn">true</span><span class="op">;</span></span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a>      <span class="va">enableFishIntegration</span> <span class="op">=</span> <span class="cn">true</span><span class="op">;</span></span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-33"><a href="#cb11-33" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Better &#39;ls&#39;</span></span>
<span id="cb11-34"><a href="#cb11-34" aria-hidden="true" tabindex="-1"></a>    <span class="va">exa</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb11-35"><a href="#cb11-35" aria-hidden="true" tabindex="-1"></a>      <span class="va">enable</span> <span class="op">=</span> <span class="cn">true</span><span class="op">;</span></span>
<span id="cb11-36"><a href="#cb11-36" aria-hidden="true" tabindex="-1"></a>      <span class="va">enableAliases</span> <span class="op">=</span> <span class="cn">true</span><span class="op">;</span></span>
<span id="cb11-37"><a href="#cb11-37" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb11-38"><a href="#cb11-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-39"><a href="#cb11-39" aria-hidden="true" tabindex="-1"></a>    <span class="co"># My favorite shell</span></span>
<span id="cb11-40"><a href="#cb11-40" aria-hidden="true" tabindex="-1"></a>    <span class="va">fish</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb11-41"><a href="#cb11-41" aria-hidden="true" tabindex="-1"></a>      <span class="va">enable</span> <span class="op">=</span> <span class="cn">true</span><span class="op">;</span></span>
<span id="cb11-42"><a href="#cb11-42" aria-hidden="true" tabindex="-1"></a>      <span class="va">package</span> <span class="op">=</span> pkgs.fish<span class="op">;</span></span>
<span id="cb11-43"><a href="#cb11-43" aria-hidden="true" tabindex="-1"></a>      <span class="va">interactiveShellInit</span> <span class="op">=</span> <span class="st">&#39;&#39;</span></span>
<span id="cb11-44"><a href="#cb11-44" aria-hidden="true" tabindex="-1"></a><span class="st">        set fish_color_normal &quot;#a4c337&quot;</span></span>
<span id="cb11-45"><a href="#cb11-45" aria-hidden="true" tabindex="-1"></a><span class="st">        set fish_color_command &quot;#77c337&quot;</span></span>
<span id="cb11-46"><a href="#cb11-46" aria-hidden="true" tabindex="-1"></a><span class="st">        set fish_color_quote &quot;#37c393&quot;</span></span>
<span id="cb11-47"><a href="#cb11-47" aria-hidden="true" tabindex="-1"></a><span class="st">        set fish_color_redirection &quot;#37b5c3&quot;</span></span>
<span id="cb11-48"><a href="#cb11-48" aria-hidden="true" tabindex="-1"></a><span class="st">        set fish_color_end &quot;#3776c3&quot;</span></span>
<span id="cb11-49"><a href="#cb11-49" aria-hidden="true" tabindex="-1"></a><span class="st">        set fish_color_error &quot;#c33759&quot;</span></span>
<span id="cb11-50"><a href="#cb11-50" aria-hidden="true" tabindex="-1"></a><span class="st">      &#39;&#39;</span><span class="op">;</span></span>
<span id="cb11-51"><a href="#cb11-51" aria-hidden="true" tabindex="-1"></a>      <span class="va">shellAliases</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb11-52"><a href="#cb11-52" aria-hidden="true" tabindex="-1"></a>        <span class="co"># exa</span></span>
<span id="cb11-53"><a href="#cb11-53" aria-hidden="true" tabindex="-1"></a>        <span class="va">ls</span> <span class="op">=</span> <span class="st">&quot;</span><span class="sc">${</span>pkgs.exa<span class="sc">}</span><span class="st">/bin/exa&quot;</span><span class="op">;</span></span>
<span id="cb11-54"><a href="#cb11-54" aria-hidden="true" tabindex="-1"></a>        <span class="va">ll</span> <span class="op">=</span> <span class="st">&quot;</span><span class="sc">${</span>pkgs.exa<span class="sc">}</span><span class="st">/bin/exa -l&quot;</span><span class="op">;</span></span>
<span id="cb11-55"><a href="#cb11-55" aria-hidden="true" tabindex="-1"></a>        <span class="va">la</span> <span class="op">=</span> <span class="st">&quot;</span><span class="sc">${</span>pkgs.exa<span class="sc">}</span><span class="st">/bin/exa -a&quot;</span><span class="op">;</span></span>
<span id="cb11-56"><a href="#cb11-56" aria-hidden="true" tabindex="-1"></a>        <span class="va">lt</span> <span class="op">=</span> <span class="st">&quot;</span><span class="sc">${</span>pkgs.exa<span class="sc">}</span><span class="st">/bin/exa --tree&quot;</span><span class="op">;</span></span>
<span id="cb11-57"><a href="#cb11-57" aria-hidden="true" tabindex="-1"></a>        <span class="va">lla</span> <span class="op">=</span> <span class="st">&quot;</span><span class="sc">${</span>pkgs.exa<span class="sc">}</span><span class="st">/bin/exa -la&quot;</span><span class="op">;</span></span>
<span id="cb11-58"><a href="#cb11-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-59"><a href="#cb11-59" aria-hidden="true" tabindex="-1"></a>        <span class="co"># git</span></span>
<span id="cb11-60"><a href="#cb11-60" aria-hidden="true" tabindex="-1"></a>        <span class="va">gs</span> <span class="op">=</span> <span class="st">&quot;</span><span class="sc">${</span>pkgs.git<span class="sc">}</span><span class="st">/bin/git status&quot;</span><span class="op">;</span></span>
<span id="cb11-61"><a href="#cb11-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-62"><a href="#cb11-62" aria-hidden="true" tabindex="-1"></a>        <span class="co"># bat</span></span>
<span id="cb11-63"><a href="#cb11-63" aria-hidden="true" tabindex="-1"></a>        <span class="va">cat</span> <span class="op">=</span> <span class="st">&quot;</span><span class="sc">${</span>pkgs.bat<span class="sc">}</span><span class="st">/bin/bat&quot;</span><span class="op">;</span></span>
<span id="cb11-64"><a href="#cb11-64" aria-hidden="true" tabindex="-1"></a>      <span class="op">};</span></span>
<span id="cb11-65"><a href="#cb11-65" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb11-66"><a href="#cb11-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-67"><a href="#cb11-67" aria-hidden="true" tabindex="-1"></a>    <span class="va">fzf</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb11-68"><a href="#cb11-68" aria-hidden="true" tabindex="-1"></a>      <span class="va">enable</span> <span class="op">=</span> <span class="cn">true</span><span class="op">;</span></span>
<span id="cb11-69"><a href="#cb11-69" aria-hidden="true" tabindex="-1"></a>      <span class="va">enableBashIntegration</span> <span class="op">=</span> <span class="cn">true</span><span class="op">;</span></span>
<span id="cb11-70"><a href="#cb11-70" aria-hidden="true" tabindex="-1"></a>      <span class="va">enableFishIntegration</span> <span class="op">=</span> <span class="cn">true</span><span class="op">;</span></span>
<span id="cb11-71"><a href="#cb11-71" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb11-72"><a href="#cb11-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-73"><a href="#cb11-73" aria-hidden="true" tabindex="-1"></a>    <span class="va">git</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb11-74"><a href="#cb11-74" aria-hidden="true" tabindex="-1"></a>      <span class="va">enable</span> <span class="op">=</span> <span class="cn">true</span><span class="op">;</span></span>
<span id="cb11-75"><a href="#cb11-75" aria-hidden="true" tabindex="-1"></a>      <span class="va">delta</span>.<span class="va">enable</span> <span class="op">=</span> <span class="cn">true</span><span class="op">;</span></span>
<span id="cb11-76"><a href="#cb11-76" aria-hidden="true" tabindex="-1"></a>      <span class="va">aliases</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb11-77"><a href="#cb11-77" aria-hidden="true" tabindex="-1"></a>        <span class="va">lol</span> <span class="op">=</span> <span class="st">&quot;log --graph --decorate --oneline --abbrev-commit&quot;</span><span class="op">;</span></span>
<span id="cb11-78"><a href="#cb11-78" aria-hidden="true" tabindex="-1"></a>        <span class="va">lola</span> <span class="op">=</span> <span class="st">&quot;log --graph --decorate --oneline --abbrev-commit --all&quot;</span><span class="op">;</span></span>
<span id="cb11-79"><a href="#cb11-79" aria-hidden="true" tabindex="-1"></a>        <span class="va">hist</span> <span class="op">=</span></span>
<span id="cb11-80"><a href="#cb11-80" aria-hidden="true" tabindex="-1"></a>          <span class="st">&quot;log --pretty=format:&#39;%h %ad | %s%d [%an]&#39; --graph --date=short&quot;</span><span class="op">;</span></span>
<span id="cb11-81"><a href="#cb11-81" aria-hidden="true" tabindex="-1"></a>        <span class="va">work</span> <span class="op">=</span> <span class="st">&quot;log --pretty=format:&#39;%h%x09%an%x09%ad%x09%s&#39;&quot;</span><span class="op">;</span></span>
<span id="cb11-82"><a href="#cb11-82" aria-hidden="true" tabindex="-1"></a>      <span class="op">};</span></span>
<span id="cb11-83"><a href="#cb11-83" aria-hidden="true" tabindex="-1"></a>      <span class="va">extraConfig</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb11-84"><a href="#cb11-84" aria-hidden="true" tabindex="-1"></a>        <span class="va">init</span>.<span class="va">defaultBranch</span> <span class="op">=</span> <span class="st">&quot;main&quot;</span><span class="op">;</span></span>
<span id="cb11-85"><a href="#cb11-85" aria-hidden="true" tabindex="-1"></a>        <span class="va">pull</span>.<span class="va">ff</span> <span class="op">=</span> <span class="st">&quot;only&quot;</span><span class="op">;</span></span>
<span id="cb11-86"><a href="#cb11-86" aria-hidden="true" tabindex="-1"></a>        <span class="va">merge</span>.<span class="va">conflictstyle</span> <span class="op">=</span> <span class="st">&quot;diff3&quot;</span><span class="op">;</span></span>
<span id="cb11-87"><a href="#cb11-87" aria-hidden="true" tabindex="-1"></a>      <span class="op">};</span></span>
<span id="cb11-88"><a href="#cb11-88" aria-hidden="true" tabindex="-1"></a>      <span class="va">ignores</span> <span class="op">=</span> <span class="op">[];</span></span>
<span id="cb11-89"><a href="#cb11-89" aria-hidden="true" tabindex="-1"></a>      <span class="va">userEmail</span> <span class="op">=</span> <span class="st">&quot;your email here&quot;</span><span class="op">;</span></span>
<span id="cb11-90"><a href="#cb11-90" aria-hidden="true" tabindex="-1"></a>      <span class="va">userName</span> <span class="op">=</span> <span class="st">&quot;your name here&quot;</span><span class="op">;</span></span>
<span id="cb11-91"><a href="#cb11-91" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb11-92"><a href="#cb11-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-93"><a href="#cb11-93" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Should probably keep this</span></span>
<span id="cb11-94"><a href="#cb11-94" aria-hidden="true" tabindex="-1"></a>    <span class="va">home-manager</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb11-95"><a href="#cb11-95" aria-hidden="true" tabindex="-1"></a>      <span class="va">enable</span> <span class="op">=</span> <span class="cn">true</span><span class="op">;</span></span>
<span id="cb11-96"><a href="#cb11-96" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb11-97"><a href="#cb11-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-98"><a href="#cb11-98" aria-hidden="true" tabindex="-1"></a>    <span class="co"># This makes it so that if you type the name of a program that</span></span>
<span id="cb11-99"><a href="#cb11-99" aria-hidden="true" tabindex="-1"></a>    <span class="co"># isn&#39;t installed, it will tell you which package contains it.</span></span>
<span id="cb11-100"><a href="#cb11-100" aria-hidden="true" tabindex="-1"></a>    <span class="va">nix-index</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb11-101"><a href="#cb11-101" aria-hidden="true" tabindex="-1"></a>      <span class="va">enable</span> <span class="op">=</span> <span class="cn">true</span><span class="op">;</span></span>
<span id="cb11-102"><a href="#cb11-102" aria-hidden="true" tabindex="-1"></a>      <span class="va">enableFishIntegration</span> <span class="op">=</span> <span class="cn">true</span><span class="op">;</span></span>
<span id="cb11-103"><a href="#cb11-103" aria-hidden="true" tabindex="-1"></a>      <span class="va">enableBashIntegration</span> <span class="op">=</span> <span class="cn">true</span><span class="op">;</span></span>
<span id="cb11-104"><a href="#cb11-104" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb11-105"><a href="#cb11-105" aria-hidden="true" tabindex="-1"></a>  <span class="op">};</span></span>
<span id="cb11-106"><a href="#cb11-106" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>You can find all <a
href="https://nix-community.github.io/home-manager/options.html">settings
for home-manager on their wiki page</a>.</p>
<p>Next, you'll have to symlink this file:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode sh"><code class="sourceCode bash"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ln</span> <span class="at">-s</span> <span class="va">$PWD</span>/shell.nix <span class="va">$HOME</span>/.config/nixpkgs/home.nix</span></code></pre></div>
<h3 id="installing-home-manager">Installing home-manager</h3>
<p>The first time you install <code>home-manager</code>, you'll have to
run:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode sh"><code class="sourceCode bash"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ex">nix-shell</span> <span class="st">&#39;&lt;home-manager&gt;&#39;</span> <span class="at">-A</span> install</span></code></pre></div>
<p>The same command needs to be executed if you update the pin for
it.</p>
<p>However, if you just update your configuration file, you can simply
run</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode sh"><code class="sourceCode bash"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ex">home-manager</span> switch</span></code></pre></div>
<h2 id="have-fun">Have fun!</h2>
<p>And that's pretty much it! You can find more inspiration in my <a
href="https://github.com/eviefp/dotfiles">config files</a>.</p>
<p>Please note I use modules a lot which I have not covered here. I do
plan to write a blog post about it later.</p>]]></content>
  </entry>
  <entry>
      <title>Bridging the Gap: Engineering Managers and Trust</title>
      <link href="https://eevie.ro/posts/2023-11-20-building-trust-as-em.html"/>
      <id>https://eevie.roposts/2023-11-20-building-trust-as-em.html</id>
      <updated>2023-11-20T00:00:SZ</updated>
      <category term="management"/>
      <category term="engineering"/>
      <summary>Bridging the Gap: Engineering Managers and Trust</summary>
      <content type="html"><![CDATA[<p>In the intricate dance of innovation and project execution, the
linchpin holding the delicate balance is trust — especially between
engineering teams and upper management. This foundational element serves
as the bedrock upon which collaborative efforts, efficient
communication, and successful outcomes rest.</p>
<h2 id="-common-signs-for-lack-of-trust">🚧 Common Signs for Lack of
Trust</h2>
<p>There's usually a few <strong>signs</strong> you can look for to see
if there's a significant gap in trust between upper management and
engineering teams. Here's a short list of the most commonly found, in my
experience:</p>
<ol>
<li><strong>High Turnover</strong> within the engineering team,</li>
<li><strong>Micromanagement</strong> and looking for hands-on/technical
staff to join the upper management team,</li>
<li><strong>Resistance to change</strong> from engineering teams to
embrace the vision and ideas coming from upper management,</li>
<li><strong>Secrecy</strong> or lack of transparency in the
decision-making process,</li>
<li><strong>Blame Culture</strong> focusing on pointing fingers rather
than finding solutions.</li>
</ol>
<p>While some of these symptoms may cause others (for example,
micromanagement may increase turnover, secrecy might increase the team's
resistance to change, etc.), they're all caused by one thing:
<strong>lack of trust</strong> between upper management and the
engineering teams.</p>
<h2 id="️-building-bridges-as-engineering-managers">🛠️ Building Bridges
as Engineering Managers</h2>
<p>Instead of relying solely on technical prowess, consider empowering
your Engineering Managers to bridge this divide. Their role extends
beyond managing projects or solving technical problems; they are
instrumental in fostering a culture of trust. By actively engaging with
both upper management and the engineering teams, they can facilitate
open communication, align goals, and strengthen collaboration.</p>
<p>First and foremost, <strong>transparent and open
communication</strong> is key for everything else. Regularly updating
both the upper management and the engineering teams on progress,
challenges and successes is essential.</p>
<p><strong>Aligning goals and expectations</strong> is a close second
when it comes to building trust. The goals must be in line with the
upper management's vision and plans, while also being realistic and
accepted by the engineering teams: alignment is a two-way street.</p>
<p><strong>Recognition and acknowledgement</strong> is essential in
building trust. And this also goes both ways. The Engineering Manager is
responsible to make sure the engineering teams understand the essential
work that upper management does, just as much as the upper management
should know about the successes and achievements of the engineering
teams.</p>
<h2 id="-why-focus-on-trust">💡 Why Focus on Trust?</h2>
<p>A lack of trust can hinder innovation, slow down decision-making, and
impede the overall progress of engineering initiatives. Engineering
Managers, adept at navigating the technical landscape and interpersonal
dynamics, can play a pivotal role in rebuilding and nurturing this
essential foundation.</p>
<p>When trust is restored, it ripples through the organization,
positively impacting morale, productivity, and ultimately, the quality
of deliverables. Investing in the right leadership at the managerial
level can be a strategic move to address the root cause of the
disconnect.</p>
<h2 id="-connect-with-purpose">🔗 Connect with Purpose</h2>
<p>Take a moment to consider your Engineering department's organisation.
Are you looking for someone hands-on/tehcnical in the upper management
because you don't trust your engineering teams? Is your company showing
signs for lack of trust?</p>
<p>If so, perhaps the solution is to empower your Engineering Managers
to bridge the trust gap.</p>]]></content>
  </entry>
  <entry>
      <title>Lean, Advent of Code and Sigma Types</title>
      <link href="https://eevie.ro/posts/2023-12-21-lean-sigma.types.html"/>
      <id>https://eevie.roposts/2023-12-21-lean-sigma.types.html</id>
      <updated>2023-12-22T00:00:SZ</updated>
      <category term="lean"/>
      <category term="advent-of-code"/>
      <category term="dependent-types"/>
      <summary>baby&#39;s first steps in beating the anxiety around using dependent types</summary>
      <content type="html"><![CDATA[<p>I've been doing this year's <a href="https://adventofcode.com">Advent
of Code</a> in <a href="https://lean-lang.org/">Lean4</a>. If you're
unfamiliar, it's a dependently language that's both a functional
programming language and a theorem prover. But before I go any further,
let me take a brief moment to cover some of the basics. Feel free to
skip this part if you're familiar with dependent types and sized
vectors.</p>
<h2 id="sized-vectors">Sized vectors</h2>
<p>Dependent languages, or languages that allow type-level natural
numbers, allow you to store the size of a vector into its type:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>inductive <span class="dt">Vector</span> (α<span class="op">:</span> <span class="dt">Type</span>)<span class="op">:</span> <span class="dt">Nat</span> → <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> nil <span class="op">:</span> <span class="dt">Vector</span> α <span class="dv">0</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> cons<span class="op">:</span> α → <span class="dt">Vector</span> α n → <span class="dt">Vector</span> α (n <span class="op">+</span> <span class="dv">1</span>)</span></code></pre></div>
<p>If you're unfamiliar with Lean syntax, it's essentially declaring a
new type called <code>Vector</code>, which takes two arguments: an
<code>α</code> which is the type of the elements the vector will hold,
and a <code>Nat</code>, which stands for natural numbers. The result is
a <code>Type</code>, which is essentially the type of
<code>Vector α n</code>, for example <code>Vector Bool 3</code> is a
vector of 3 booleans.</p>
<p>The following two lines are the two constructors: <code>nil</code>
which creates a vector of size 0 with no values, and <code>cons</code>,
which takes one more value (the single <code>α</code>), and a vector of
size <code>n</code> to create a vector of size <code>n + 1</code>.</p>
<p>What this means is, an empty, or <code>nil</code> vector will
<em>always</em> have a size of 0, because you can't construct it
otherwise. Similarly, whatever the size of the vector, it will always
have that many elements in it.</p>
<p>Here are a few quick examples:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>def empty   <span class="op">:</span> <span class="dt">Vector</span> <span class="dt">Bool</span> <span class="dv">0</span> <span class="op">:=</span> nil</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>def oneBool <span class="op">:</span> <span class="dt">Vector</span> <span class="dt">Bool</span> <span class="dv">1</span> <span class="op">:=</span> cons true nil</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>def twoBools<span class="op">:</span> <span class="dt">Vector</span> <span class="dt">Bool</span> <span class="dv">2</span> <span class="op">:=</span> cons true (cons false nil)</span></code></pre></div>
<p>If we ask for the element at some position, as long as that number is
smaller than the natural parameter of the Vector, we can always just
grab it! Lean has a type that helps with that: <code>Fin</code> carries
a natural number, and the <em>proof</em> that it is
<strong>smaller</strong> than some other natural number,
<strong>n</strong>:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>structure <span class="dt">Fin</span> (n <span class="op">:</span> <span class="dt">Nat</span>) <span class="kw">where</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  val  <span class="op">:</span> <span class="dt">Nat</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  isLt <span class="op">:</span> <span class="dt">LT</span><span class="op">.</span>lt val n     <span class="co">-- LT stands for Lower Than; this reads as &#39;val &lt; n&#39;</span></span></code></pre></div>
<p>Which means we can now write a <code>get</code> function for our
vector type:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>def get<span class="op">:</span> <span class="dt">Fin</span> n → <span class="dt">Vector</span> α n → α</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> ⟨<span class="dv">0</span>    , h⟩, <span class="op">.</span>cons x xs ⇒ x</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> ⟨i <span class="op">+</span> <span class="dv">1</span>, h⟩, <span class="op">.</span>cons x xs ⇒ get ⟨i, Nat.le_of_succ_le_succ h⟩ xs</span></code></pre></div>
<p>How this works out is:</p>
<ul>
<li>you cannot write <code>Fin 0</code> because you can't create a proof
that any <em>natural</em> number is smaller than 0</li>
<li>which, in turn means, there's no missing case for <code>.nil</code>:
it's impossible to call this function on an empty vector!</li>
<li>if we reached 0 (the value stored in <code>Fin n</code>;
<code>n</code> can never be 0!), we'll just return the top element of
the (deconstructed) vector</li>
<li>otherwise, we recursively call <code>get</code> with
<code>i - 1</code> (or, rather, match on <code>i + 1</code> and call it
with <code>i</code>)</li>
<li>since <code>xs</code> now has size <code>n - 1</code>, we need to
also construct a <code>Fin (n - 1)</code></li>
<li>we need to create the proof that <code>i - 1 &lt; n - 1</code>,
given <code>h: i &lt; n</code></li>
<li>that proof already exists, and that's
<code>Nat.le_of_succ_le_succ</code></li>
<li>we know <code>Fin n</code> and <code>Vector α n</code> have the same
<code>n</code>, so we can never reach 0 before running out of Vector
<code>cons</code> or values</li>
</ul>
<p>Whew! There's a lot going in in those packed 2 lines of code.</p>
<p>And before we move on, I just have to share this:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>def <span class="fu">length</span><span class="op">:</span> <span class="dt">Vector</span> α n → <span class="dt">Nat</span> <span class="op">:=</span> λ _ ⇒ n</span></code></pre></div>
<p>Normally, with a list, we'd need to iterate through all of it to find
its length. However, since we keep track of the size of the vector in
its type, and well, Lean is a dependently typed language, we can just
grab that <code>n</code> from Vector's type and return it as a
value!</p>
<p>It seems so natural, and yet, it's either impossible or requires
quite some elaborate tricks in languages without dependent type
support.</p>
<h2 id="back-to-advent-of-code">Back to Advent of Code</h2>
<p>This year's Advent of Code (AoC) featured quite a few puzzles where a
<code>Grid</code> type comes in handy, specifically when a rectangular
map is a reasonable way to model the problem. For example, if you wanted
to represent a cell that can either be a wall or an empty space, one can
easily write</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>inductive <span class="dt">Cell</span> <span class="kw">where</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Wall</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Space</span></span></code></pre></div>
<p>And there's plenty of ways to represent a map, such as:</p>
<ul>
<li>a list of lists</li>
<li>a (hash)map of coordinates to cell</li>
<li>a function from coordinate to cell</li>
</ul>
<p>However, I went for a 2D vector, and since not all grids (/maps) are
square, it'll need both a width (x) and a height (y):</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>structure <span class="dt">Grid</span> (x<span class="op">:</span> <span class="dt">Nat</span>) (y<span class="op">:</span> <span class="dt">Nat</span>) (α<span class="op">:</span> <span class="dt">Type</span>) <span class="kw">where</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">data</span><span class="op">:</span> <span class="dt">Vector</span> (<span class="dt">Vector</span> α x) y</span></code></pre></div>
<p>So once I wrote this and a few helper functions, I was ready to start
using it. And naturally, I wanted to write a parser to read up the input
for the day's puzzle:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>def parseInput<span class="op">:</span> <span class="dt">Parsec</span> (<span class="dt">Grid</span> x y <span class="dt">Cell</span>) <span class="op">:=</span> <span class="op">...</span></span></code></pre></div>
<p>But, whoops. This won't work. <code>x</code> and <code>y</code> are
universally quantified, which means that the <strong>caller</strong> of
<code>parseInput</code> gets to decide what they are. However, it's not
up to them! It's up to <code>parseInput</code> to read the input file
and figure out <code>x</code> and <code>y</code>. So, essentially, they
need to be existentially quantified. In other words, they are
<em>outputs</em> and not <em>inputs</em>.</p>
<p>And well, thanks to being used with Haskell and other non-dependently
typed languages, I've been going for a different approach until
today:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>def parseInput<span class="op">:</span> <span class="dt">Parsec</span> (<span class="dt">List</span> (<span class="dt">List</span> <span class="dt">Cell</span>)) <span class="op">:=</span> <span class="op">...</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- ...</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>def solve (inputs<span class="op">:</span> <span class="dt">List</span> (<span class="dt">List</span> <span class="dt">Cell</span>))<span class="op">:</span> <span class="dt">Nat</span> <span class="op">:=</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- convert the list of lists to a grid</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- and use the grid here</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- in this context we know `x` and `y` so it&#39;s fine</span></span></code></pre></div>
<h2 id="sigma-types-to-the-rescue">Sigma types to the rescue!</h2>
<p>But all the awkwardness of passing in that list of lists instead of a
grid finally caught up to me, and today I spent more than a few seconds
thinking about it, and well, I decided to see whether an existential
type would work. I haven't gotten to use Lean that much yet, but I do
remember seeing this type, which looks like what I need:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>structure <span class="dt">Sigma</span> {α <span class="op">:</span> <span class="dt">Type</span> u} (β <span class="op">:</span> α → <span class="dt">Type</span> v) <span class="kw">where</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fst</span> <span class="op">:</span> α</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">snd</span> <span class="op">:</span> β <span class="fu">fst</span></span></code></pre></div>
<p>Let me explain the syntax for a bit: the curly braces mean "implicit
argument", which basically means, Lean will figure it out on its own
from the other arguments -- in this case, the second argument named
<code>β</code>.</p>
<p>And what is <code>β</code>? A type-level function that takes an
<code>α</code> and returns a type.</p>
<p>And this sounds exactly like what we want: we have our
<code>Grid</code> type which takes two naturals, but we don't want to
use them explicitly, so what if we wrote:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>def <span class="dt">SomeGrid</span> (pair<span class="op">:</span> <span class="dt">Nat</span> × <span class="dt">Nat</span>)<span class="op">:</span> <span class="dt">Type</span> <span class="op">:=</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Grid</span> pair<span class="op">.</span><span class="fu">fst</span> pair<span class="op">.</span><span class="fu">snd</span> <span class="dt">Cell</span></span></code></pre></div>
<p>This basically says, give me a pair of natural numbers, and I'll give
you a type. That type is a <code>Grid</code> where the <code>x</code> is
the first part of the pair, and the <code>y</code> is the second. And
yes, since types and values live at the same level, we don't need
special syntax to define type-level functions: we can write it like any
other function.</p>
<p>And now, we can write our parser like this:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>def parseGrid<span class="op">:</span> <span class="dt">Parsec</span> (<span class="dt">Sigma</span> <span class="dt">SomeGrid</span>) <span class="op">:=</span> <span class="op">...</span></span></code></pre></div>
<p>... and the awesome thing is, we can grab any
<code>Sigma SomeGrid</code> value and use it as a regular pair:</p>
<ul>
<li>its <code>fst</code> argument will just be a pair of natural numbers
which represent the size of the grid</li>
<li>its <code>snd</code> argument is our <code>Grid x y Cell</code></li>
</ul>
<p>I'll admit I was rather surprised to see that it all worked as simply
as I expected, without any surprises or hard-to-read type-level errors.
It might just be the case that my Haskell experience trying to play with
dependent types has scared me a bit too much, so I'm looking forward to
using Lean a bit more!</p>
<p>And since I've mentioned it, my full advent of code solutions up to
today (day 22) are on github: <a
href="https://github.com/eviefp/lean4-aoc2023"
class="uri">https://github.com/eviefp/lean4-aoc2023</a></p>]]></content>
  </entry>
</feed>
