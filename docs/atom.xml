<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Vladimir Ciobanu&#39;s Blog</title>
    <link href="https://cvlad.info/atom.xml" rel="self" type="application/rss+xml" />
  <updated>2020-11-25T13:41:SZ</updated>
  <author>
      <name>Vladimir Ciobanu</name>
  </author>
  <id>https://cvlad.info/</id>

  <entry>
      <title>My Haskell Journey</title>
      <link href="https://cvlad.infoposts/2018-08-10-haskell.html"/>
      <id>https://cvlad.infoposts/2018-08-10-haskell.html</id>
      <updated>2018-08-10T00:00:SZ</updated>
      <category term="fp"/>
      <category term="personal"/>
      <summary>How I learned Haskell</summary>
      <content type="html"><![CDATA[<p>It's been a while since my previous post, but it's been a crazy few months. I'm happy to be able to write again, and I'll try to do it more regularly. This post will be a bit different; it will be a personal and entirely subjective description of my journey so far in functional programming. The reason I'm writing this now is because I will soon start working at <a href="https://twitter.com/cvlad/status/1023957257841778688">Runtime Verification</a>, my first FP job.</p>
<h2 id="background">Background</h2>
<p>I've been doing C# web development for about 15 years. Although I did not really understand much of FP, I was an eager early adopter of all functional-style features C# added over the years (LINQ, anonymous functions/lambdas, etc). Every other year, I'd look up the latest Haskell books or tutorials and give it a go, but it never really worked out for me due to various reasons (no real purpose, no sense of achieving anything, not understanding the benefits of what I'm learning, etc). Ultimately, I was never able to get past toy functions in the interpreter. But I was very intrigued by Haskell's elegance.</p>
<h2 id="the-fp-slack-community">The FP Slack Community</h2>
<p>One of the best decisions I made was to look up FP-related communities. I stumbled upon the awesome <a href="https://fpchat-invite.herokuapp.com/">FP Slack</a> community. That's where I found a bunch of passionate, helpful and very knowledgeable people. They pointed me into the correct direction countless times and helped me dodge frustrating experiences. Following is a list of the pitfalls I ran into while learning Haskell, along with what I wish I knew at the time.</p>
<h3 id="installing-haskell">Installing Haskell</h3>
<p>In my experience, the best way to install Haskell is using <code>stack</code>. It's a cross-platform tool for developing Haskell projects, and it helps with managing dependencies as well as GHC (the Glasgow Haskell Compiler) versions for each of your projects. Please check their <a href="https://docs.haskellstack.org/en/stable/README/">documentation page</a> on how to install. If you already have it, make sure you upgrade it via <code>stack upgrade</code>.</p>
<p>In order to start a new project, you can run:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>$ <span class="ex">stack</span> new project</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>$ <span class="bu">cd</span> project</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>$ <span class="ex">stack</span> build</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>$ <span class="ex">stack</span> exec -- project-exe</span></code></pre></div>
<p>You should now be able to edit either <code>app/Main.hs</code> or <code>src/Lib.hs</code> to change your program.</p>
<h3 id="writing-haskell-programs">Writing Haskell Programs</h3>
<p>I regret not listening to people's advice about this sooner and spending a lot of time looking for the best Haskell IDE / development tools. In the end, everybody else was right and unfortunately, the current state of the available tools is <em>not good enough</em>. The process that most people seem to use, and the one I also adopted is using my favorite text editor with syntax highlighting. I have a few separate console windows that run <code>ghcid</code> and <code>ghci</code>.</p>
<p><code>ghcid</code> is a lightning fast way to get feedback about your code as you work on it. Once you are in your project's root, you can run <code>stack build ghcid</code> in order to build the appropriate <code>ghcid</code> version for the current project's <code>GHC</code>. Once you do that, you can run <code>ghcid</code> using <code>stack exec -- ghcid -c "stack ghci project"</code>. As soon as you edit (and save) any of the Haskell files in the project, it will recompile and let you know if anything is wrong.</p>
<p>There are a few interesting tricks you can do with <code>ghcid</code>, out of which I'd like to point out two that I find most useful. The first is really a GHC feature, which really shines when used with <code>ghcid</code>. Whenever you're not sure what to do in a function, you can throw in an underscore and save the file. The compiler will figure out the type of what the underscore needs to be replaced with, and will suggest functions in scope that match that pattern. This feature is called typed holes, and if you want to read more about how it works, I suggest you read <a href="https://twitter.com/kritzcreek">Christoph Hegemann</a>'s excellent thesis, <a href="https://www.dropbox.com/s/vfkgafoo3mofvac/bachelor_arbeit_christoph_hegemann.pdf?dl=0">Implementing type directed search for PureScript</a>.</p>
<p>The other trick with <code>ghcid</code> is, whenever you wish you had <em>hover-to-see-type</em>, you can add parenthesis around that expression and add a type annotation, e.g. <code>(whatTypeIsThis :: ())</code>. This basically asserts <code>whatTypeIsThis</code> has type <code>()</code>, or <code>Unit</code>. When you save, you will get an error saying that <code>()</code> cannot be unified with <em>actual type of the expression</em> (of course, unless the type actually is <code>()</code>).</p>
<p>The interactive Haskell shell is great when you want to try things out, or do a quick test for a function you wrote. In order to launch it, you need to run <code>stack ghci project</code>. You can then type <code>:l Lib</code> to load the <code>Lib</code> module. Once you do that, you can execute any function defined in <code>Lib</code>. If you change the code in your source files, you'll have to reload using <code>:r</code>.</p>
<h3 id="looking-up-stuff">Looking up stuff</h3>
<p>Whenever I need to look something up, my go-to place is <a href="https://hoogle.haskell.org/">hoogle</a>. You can search for functions or types by name and by signature. This feature was very useful for me as a beginner, since once you get a hang of types, you'll sort of know what signature of a function you need but not know its name. As you look stuff up, I encourage you to look at the source code of the functions you look up.</p>
<p>When looking for packages, start with <a href="https://www.stackage.org/">stackage</a>, mostly because it will only show packages that are compatible with a certain GHC version and among themselves. If you try to mix and match by yourself through <a href="https://hackage.haskell.org/packages/browse">hackage</a>, you might end up with frustrating problems.</p>
<p>Once you find a package you'd like to add, you can edit the <code>package.yaml</code> file under <code>dependencies</code> and just add the package you want by name. You'll need to rebuild the project via <code>stack build</code>.</p>
<h2 id="the-haskell-book">The Haskell Book</h2>
<p>The most recommended book on the FP slack is <a href="http://haskellbook.com/">Haskell Programming from first principles</a>, and for good reason - it was absolutely key in my learning process. It's filled with exercises guiding you through the Haskell language, as well as excellent explanations and tips. There isn't much more I can say other than, if you want to learn Haskell, this is where you should start, and if you do, please work through the exercises.</p>
<h2 id="blogs-and-other-resources">Blogs and other resources</h2>
<p>There are a lot of awesome blogs and resources for Haskell out there, and I want to mention particularly <a href="http://www.parsonsmatt.org/">Matt Parson's blog</a> and <a href="http://dev.stephendiehl.com/hask/">Stephen Diehl's What I wish I knew when learning Haskell</a> as being excellent resources.</p>
<p>My personal interest in CS led me to reading several books on topics such as Type Theory or Category Theory. They are in no way required or necessary in order to learn Haskell, but they helped me and I think they are interesting:</p>
<ul>
<li>Bartosz Mileski's <a href="https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/">blogs</a> / <a href="https://www.youtube.com/playlist?list=PLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_">videos</a></li>
<li>David Spivak's <a href="https://www.youtube.com/watch?v=IBeceQHz2x8">videos</a> and books (<a href="https://github.com/mmai/Category-Theory-for-the-Sciences">one</a> and <a href="http://math.mit.edu/~dspivak/teaching/sp18/">two</a>)</li>
<li><a href="https://www.amazon.com/Types-Programming-Languages-MIT-Press/dp/0262162091">TAPL</a></li>
<li><a href="https://www.amazon.com/Type-Theory-Formal-Proof-Introduction/dp/110703650X">Type Theory and Formal Proof</a></li>
<li><a href="https://softwarefoundations.cis.upenn.edu/current/index.html">Software Foundations</a></li>
</ul>
<h2 id="show-and-tell">Show and tell</h2>
<p>Soon after I started reading the Haskell Book, I started understanding the benefits of FP. During this time, we were having some issues at work with the quality of our TypeScript code base. The code was brittle and we were often afraid to change it. I proposed we spent some time learning FP and try out PureScript (which is very similar to Haskell, but generates JavaScript).</p>
<p>For the next few months, I went through the Haskell Book and presented it bit by bit to my colleagues and did exercises together. This helped me immensely. Just preparing the chapters in order to present them to other people does wonders on your understanding; and actually presenting and trying to figure out answers to their questions was important for me.</p>
<p>Once we went through most of the book, we turned to PureScript. This has proven to be a very good choice for me, since PureScript is a slightly more modern language, and being already comfortable with JavaScript helped a lot. I was able to build useful software, while building apps that were familiar, in an unfamiliar way.</p>
<h2 id="writing-apps">Writing apps</h2>
<p>Shortly after, we started prototyping applications in PureScript and integrating them with our codebase. We were comfortable enough with the language to convince our management and product owners to let us create a PoC using PureScript, and they agreed. The results were impressive; we were able to develop the application about as fast as we would in TypeScript, with less bugs and back and forth with QA. The next app was even faster and the benefits more clear.</p>
<h2 id="applying-for-the-job">Applying for the job</h2>
<p>I was not sure I was ready to switch to a full-time Haskell job when I found out about Runtime Verification and that they are hiring. In order to apply, I completed the <a href="http://www.kframework.org/index.php/K_Project_Needs_Professional_Developers">K Challenge</a>. This was ideal for me since I knew I could use as much time as I wanted for it. I ended up not needing too much time to get a decent implementation done, but the ease of mind that I could do it at my own pace mattered a lot for me.</p>
<p>Moreover, I was personally interested in Formal Verification, and the RV approach seems very appealing to me. I'm really happy to be able to be part of the team working on the <a href="https://github.com/kframework/kore">Kore Language</a>.</p>
<h2 id="closing-thoughts">Closing thoughts</h2>
<p>Because this is about Haskell, I've left out a lot of details about PureScript. I believe PureScript, as well as its incredibly friendly community, were very important in my journey. They helped me a lot and I'll try my best to give back to this awesome community through code contributions and spreading the word.</p>
<p>I became a strong believer in FP, in strong typing, and in compilers guiding me through programming. I strongly believe that any programmer can benefit from learning Haskell. Even though I am still relatively new in this journey, I consider myself a better programmer than I was when I started this journey and I'm looking forward to learn more about Haskell, Type Theory, Category Theory, and Formal Verification.</p>
<p>Without trying to sound too stuck up in my newly discovered FP ivory tower, I'd like to point out that we, as programmers are extremely fortunate to get very good pay compared to the standard we are held against, most of the time. <a href="https://twitter.com/bitemyapp">Chris Allen</a>, one of the authors of the Haskell Book <a href="https://www.youtube.com/watch?v=2xyZeovFqCA">talks about this</a> at LambdaConf, but my takeaway from it is, there's no organization that takes away our programmer's badge if we write terrible code or make bad decisions, or if we fail to stay in touch with technology or practices. But we definitely should, we should challenge ourselves to continuously learn, read other people's code, contribute and, perhaps most importantly, work on projects outside of our comfort zone.</p>]]></content>
  </entry>
  <entry>
      <title>Classical Logic in Haskell</title>
      <link href="https://cvlad.infoposts/2018-12-14-clasical-logic-in-haskell.html"/>
      <id>https://cvlad.infoposts/2018-12-14-clasical-logic-in-haskell.html</id>
      <updated>2018-12-14T00:00:SZ</updated>
      <category term="theory"/>
      <category term="logic"/>
      <category term="haskell"/>
      <summary>Because why not</summary>
      <content type="html"><![CDATA[<p>During a very pleasant conversation at a recent <a href="http://bucharestfp.ro">Bucharest FP</a> meetup, <a href="https://twitter.com/igstan">somebody</a> mentioned that <code>Cont</code> is, almost exactly, <a href="https://en.wikipedia.org/wiki/Peirce%27s_law"><em>Peirce's law</em></a>. I remembered seeing a <a href="https://twitter.com/paf31/status/1040304689932165120">tweet</a> from Phil Freeman which proves that they are indeed equivalent. I thought it would be a fun exercise to prove other equivalences from classical logic.</p>
<p>This post assumes you are familar with: - the <a href="https://www.youtube.com/watch?v=aeRVdYN6fE8">Curry-Howard correspondence</a>, - classical and intuitionistic logic (for example, see it explained using Coq in <a href="https://softwarefoundations.cis.upenn.edu/current/lf-current/Logic.html">Software Foundations</a>), and - one of Haskell, Agda, Idris or Coq.</p>
<h1 id="monadcont-and-the-law-of-excluded-middle">MonadCont and the Law of Excluded Middle</h1>
<p>Haskell and PureScript define <code>MonadCont</code>, which represent monads that support the <em>call-with-current-continuation</em> (<code>callCC</code>) operation:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">MonadCont</span> m <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    callCC ::</span> ((a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m a) <span class="ot">-&gt;</span> m a </span></code></pre></div>
<p><code>callCC</code> generally calls the function it receives, passing it the current continuation (the <code>a -&gt; m b</code>). This acts like an <code>abort</code> method, or an early exit.</p>
<p>The interesting part is that this monad looks very similar to <em>Peirce's law</em>:</p>
<p>$ ((P \to Q) \to P) \to P $</p>
<p>If we replace <code>P</code> with <code>a</code> (or <code>m a</code>) and <code>Q</code> with <code>m b</code>, we get the exact same thing. Since we are dealing with monads, we need to use Kleisli arrows, so all implications from logic must be lifted as such (so <code>P -&gt; Q</code> becomes <code>a -&gt; m b</code>).</p>
<h2 id="proving-equivalences">Proving equivalences</h2>
<p>In order to keep things clean, I decided to wrap each equivalent law in its own newtype and write an instance of <code>Iso</code> (which translates to iff) between each of the laws and the <em>law of excluded middle</em>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE InstanceSigs          #-}</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE RankNTypes            #-}</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ScopedTypeVariables   #-}</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Logic</span> <span class="kw">where</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Control.Applicative</span> (liftA2)</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Control.Monad</span>       ((&lt;=&lt;))</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Data.Void</span>           (<span class="dt">Void</span>, absurd)</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Iso</span> a b <span class="kw">where</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="ot">    to ::</span> a <span class="ot">-&gt;</span> b</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a><span class="ot">    from ::</span> b <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>This is just a neat way of having to prove both implications in an iff, packed as <code>to</code> and <code>from</code>. Moving on, we can declare the following types:</p>
<h3 id="peirces-law">Peirce's law</h3>
<p>Starting with the formula from logic, we can easily write out the Haskell type by just keeping in mind we have to transform all implications to Kleisli arrows:</p>
<p>$ \forall P, Q. ((P \to Q) \to P) \to P $</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Peirce</span> m <span class="ot">=</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Peirce</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        (  <span class="kw">forall</span> a b</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>  ((a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m a)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>        <span class="ot">-&gt;</span> m a</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>        )</span></code></pre></div>
<h3 id="law-of-excluded-middle">Law of Excluded Middle</h3>
<p>The key part to remember here is that negation in classical logic translates to <code>-&gt; Void</code> in intuitionistic logic (and <code>-&gt; m Void</code> in our case, since we are using Kleisli arrows):</p>
<p>$ \forall P. P \lor \neg P $</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Lem</span> m <span class="ot">=</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Lem</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>        (  <span class="kw">forall</span> a</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>  m (<span class="dt">Either</span> a (a <span class="ot">-&gt;</span> m <span class="dt">Void</span>))</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>        )</span></code></pre></div>
<h3 id="double-negation">Double Negation</h3>
<p>Nothing new here, just rewriting negation as <code>-&gt; m Void</code>:</p>
<p>$ \forall P. \neg \neg P \to P $</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">DoubleNegation</span> m <span class="ot">=</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">DoubleNegation</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>        (  <span class="kw">forall</span> a</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>  ((a <span class="ot">-&gt;</span> m <span class="dt">Void</span>) <span class="ot">-&gt;</span> m <span class="dt">Void</span>)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>        <span class="ot">-&gt;</span> m a</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>        )</span></code></pre></div>
<h3 id="de-morgans-law">De Morgan's Law</h3>
<p>The only new thing here is that we translate <code>and</code> to tuples, and <code>or</code> to Either:</p>
<p>$ \forall P, Q. \neg (\neg P \land \neg Q) \to P \lor Q $</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">DeMorgan</span> m <span class="ot">=</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">DeMorgan</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>        (  <span class="kw">forall</span> a b</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>  ((a <span class="ot">-&gt;</span> m <span class="dt">Void</span>, b <span class="ot">-&gt;</span> m <span class="dt">Void</span>) <span class="ot">-&gt;</span> m <span class="dt">Void</span>)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>        <span class="ot">-&gt;</span> m (<span class="dt">Either</span> a b)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>        )</span></code></pre></div>
<h3 id="implication-to-disjunction">Implication to Disjunction</h3>
<p>$ \forall P, Q. (P \to Q) \to Q \lor \neg P $</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">ImpliesToOr</span> m <span class="ot">=</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">ImpliesToOr</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>        (  <span class="kw">forall</span> a b</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>  (a <span class="ot">-&gt;</span> m b)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>        <span class="ot">-&gt;</span> m (<span class="dt">Either</span> b (a <span class="ot">-&gt;</span> m <span class="dt">Void</span>))</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        )</span></code></pre></div>
<h2 id="proofs">Proofs</h2>
<p>If this is interesting to you, this would be a good place to look away and try for yourself. If you do, keep in mind that typed holes are a very useful tool in this process (see <a href="https://wiki.haskell.org/GHC/Typed_holes">this</a> for an example).</p>
<h3 id="lem-and-peirce">Lem and Peirce</h3>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Iso</span> (<span class="dt">Lem</span> m) (<span class="dt">Peirce</span> m) <span class="kw">where</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    to ::</span> <span class="dt">Lem</span> m <span class="ot">-&gt;</span> <span class="dt">Peirce</span> m</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    to (<span class="dt">Lem</span> lem) <span class="ot">=</span> <span class="dt">Peirce</span> proof</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>      <span class="kw">where</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>        proof</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="ot">            ::</span> ((a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m a)</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>            <span class="ot">-&gt;</span> m a</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>        proof abort <span class="ot">=</span> lem <span class="op">&gt;&gt;=</span> <span class="fu">either</span> <span class="fu">pure</span> (go abort)</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>        go</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span class="ot">            ::</span> ((a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m a)</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>            <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m <span class="dt">Void</span>)</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>            <span class="ot">-&gt;</span> m a</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>        go abort not_a <span class="ot">=</span> abort <span class="op">$</span> <span class="fu">fmap</span> absurd <span class="op">.</span> not_a</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a><span class="ot">    from ::</span> <span class="dt">Peirce</span> m <span class="ot">-&gt;</span> <span class="dt">Lem</span> m</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>    from (<span class="dt">Peirce</span> p) <span class="ot">=</span> <span class="dt">Lem</span> <span class="op">$</span> p go</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>      <span class="kw">where</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>        go</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a><span class="ot">            ::</span> (<span class="dt">Either</span> a (a <span class="ot">-&gt;</span> m <span class="dt">Void</span>) <span class="ot">-&gt;</span> m <span class="dt">Void</span>)</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>            <span class="ot">-&gt;</span> m (<span class="dt">Either</span> a (a <span class="ot">-&gt;</span> m <span class="dt">Void</span>))</span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>        go not_lem <span class="ot">=</span> <span class="fu">pure</span> <span class="op">.</span> <span class="dt">Right</span> <span class="op">$</span> not_lem <span class="op">.</span> <span class="dt">Left</span></span></code></pre></div>
<h3 id="lem-and-doublenegation">Lem and DoubleNegation</h3>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Iso</span> (<span class="dt">Lem</span> m) (<span class="dt">DoubleNegation</span> m) <span class="kw">where</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    to ::</span> <span class="dt">Lem</span> m <span class="ot">-&gt;</span> <span class="dt">DoubleNegation</span> m</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    to (<span class="dt">Lem</span> lem) <span class="ot">=</span> <span class="dt">DoubleNegation</span> proof</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>      <span class="kw">where</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>        proof</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="ot">            ::</span> ((a <span class="ot">-&gt;</span> m <span class="dt">Void</span>) <span class="ot">-&gt;</span> m <span class="dt">Void</span>)</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>            <span class="ot">-&gt;</span> m a</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>        proof notNot <span class="ot">=</span> lem <span class="op">&gt;&gt;=</span> <span class="fu">either</span> <span class="fu">pure</span> (go notNot)</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>        go</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a><span class="ot">            ::</span> ((a <span class="ot">-&gt;</span> m <span class="dt">Void</span>) <span class="ot">-&gt;</span> m <span class="dt">Void</span>)</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>            <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m <span class="dt">Void</span>)</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>            <span class="ot">-&gt;</span> m a</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>        go notNot notA <span class="ot">=</span> <span class="fu">fmap</span> absurd <span class="op">$</span> notNot notA</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a><span class="ot">    from ::</span> <span class="dt">DoubleNegation</span> m <span class="ot">-&gt;</span> <span class="dt">Lem</span> m</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>    from (<span class="dt">DoubleNegation</span> dne) <span class="ot">=</span> <span class="dt">Lem</span> <span class="op">$</span> dne not_exists_dist</span></code></pre></div>
<h3 id="lem-and-demorgan">Lem and DeMorgan</h3>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Iso</span> (<span class="dt">Lem</span> m) (<span class="dt">DeMorgan</span> m) <span class="kw">where</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    to ::</span> <span class="dt">Lem</span> m <span class="ot">-&gt;</span> <span class="dt">DeMorgan</span> m</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    to (<span class="dt">Lem</span> lem) <span class="ot">=</span> <span class="dt">DeMorgan</span> proof</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>      <span class="kw">where</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>        proof</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="ot">            ::</span> ((a <span class="ot">-&gt;</span> m <span class="dt">Void</span>, b <span class="ot">-&gt;</span> m <span class="dt">Void</span>) <span class="ot">-&gt;</span> m <span class="dt">Void</span>)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>            <span class="ot">-&gt;</span> m (<span class="dt">Either</span> a b)</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>        proof notNotANotB <span class="ot">=</span> lem <span class="op">&gt;&gt;=</span> <span class="fu">either</span> <span class="fu">pure</span> (go notNotANotB)</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>        go</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="ot">            ::</span> ((a <span class="ot">-&gt;</span> m <span class="dt">Void</span>, b <span class="ot">-&gt;</span> m <span class="dt">Void</span>) <span class="ot">-&gt;</span> m <span class="dt">Void</span>)</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>            <span class="ot">-&gt;</span> (<span class="dt">Either</span> a b <span class="ot">-&gt;</span> m <span class="dt">Void</span>)</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>            <span class="ot">-&gt;</span> m (<span class="dt">Either</span> a b)</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>        go notNotANotB <span class="ot">=</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>            <span class="fu">fmap</span> absurd</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span> notNotANotB</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span> liftA2 (,) (<span class="op">.</span> <span class="dt">Left</span>) (<span class="op">.</span> <span class="dt">Right</span>)</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a><span class="ot">    from ::</span> <span class="dt">DeMorgan</span> m <span class="ot">-&gt;</span> <span class="dt">Lem</span> m</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>    from (<span class="dt">DeMorgan</span> dm) <span class="ot">=</span> <span class="dt">Lem</span> <span class="op">$</span> dm go</span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>      <span class="kw">where</span></span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>        go</span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a><span class="ot">            ::</span> (a <span class="ot">-&gt;</span> m <span class="dt">Void</span>, (a <span class="ot">-&gt;</span> m <span class="dt">Void</span>) <span class="ot">-&gt;</span> m <span class="dt">Void</span>)</span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>            <span class="ot">-&gt;</span> m <span class="dt">Void</span></span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>        go (notA, notNotA) <span class="ot">=</span> notNotA notA</span></code></pre></div>
<h3 id="lem-and-impliestoor">Lem and ImpliesToOr</h3>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Iso</span> (<span class="dt">Lem</span> m) (<span class="dt">ImpliesToOr</span> m) <span class="kw">where</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    to ::</span> <span class="dt">Lem</span> m <span class="ot">-&gt;</span> <span class="dt">ImpliesToOr</span> m</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    to (<span class="dt">Lem</span> lem) <span class="ot">=</span> <span class="dt">ImpliesToOr</span> proof</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>      <span class="kw">where</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>        proof</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="ot">            ::</span> (a <span class="ot">-&gt;</span> m b)</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>            <span class="ot">-&gt;</span> m (<span class="dt">Either</span> b (a <span class="ot">-&gt;</span> m <span class="dt">Void</span>))</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>        proof fab <span class="ot">=</span> <span class="fu">either</span> <span class="dt">Left</span> (go fab) <span class="op">&lt;$&gt;</span> lem</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>        go</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a><span class="ot">            ::</span> (a <span class="ot">-&gt;</span> m b)</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>            <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> m <span class="dt">Void</span>)</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>            <span class="ot">-&gt;</span> <span class="dt">Either</span> b (a <span class="ot">-&gt;</span> m <span class="dt">Void</span>)</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>        go fab notB <span class="ot">=</span> <span class="dt">Right</span> <span class="op">$</span> notB <span class="op">&lt;=&lt;</span> fab</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a><span class="ot">    from ::</span> <span class="dt">ImpliesToOr</span> m <span class="ot">-&gt;</span> <span class="dt">Lem</span> m</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>    from (<span class="dt">ImpliesToOr</span> im) <span class="ot">=</span> <span class="dt">Lem</span> <span class="op">$</span> im <span class="fu">pure</span></span></code></pre></div>
<p>The full source code is available on <a href="https://github.com/vladciobanu/logic-in-haskell">my github</a>.</p>]]></content>
  </entry>
  <entry>
      <title>Curry-Howard Correspondence Example</title>
      <link href="https://cvlad.infoposts/2019-02-02-curry-howard.html"/>
      <id>https://cvlad.infoposts/2019-02-02-curry-howard.html</id>
      <updated>2019-02-02T00:00:SZ</updated>
      <category term="haskell"/>
      <category term="theory"/>
      <summary>More Logic in PL</summary>
      <content type="html"><![CDATA[<p>I previously showed some fun <a href="/clasical-logic-in-haskell/">classical logic proofs in Haskell</a>, thanks to the Curry-Howard correspondence. I recommend you also check out my <a href="https://cs.unibuc.ro/~ddiaconescu/">wife's</a> slides from her <a href="https://drive.google.com/file/d/1ghFPbIZ4r8-291f6weszNxLwMXu1U8kx/view">Curry-Howard-Lambek correspondence presentation</a>.</p>
<p>This post will show how a simple proof works in Logic, Type Theory, and Category Theory: given <code>A ∧ (B ∧ C)</code>, prove <code>(A ∧ B) ∧ C</code>.</p>
<h2 id="logic">Logic</h2>
<p>In logic, there are several systems that allows us to reason about propositions. One of them is the natural deduction system and is defined using introduction and elimination rules. For each connective, or operator, we will have at least one of each introduction and elimination rules.</p>
<p>For example, conjunction (<code>∧</code>) has one introduction rule:</p>
<pre><code> A   B
------- (∧i)
 A ∧ B</code></pre>
<p>which means, if we know <code>A</code> and <code>B</code>, then we can use the introduction rule (<code>∧i</code>) to deduce the proposition <code>A ∧ B</code>.</p>
<p>There are two elimination rules for <code>∧</code>:</p>
<pre><code>A ∧ B                 A ∧ B
----- (∧e1)           ----- (∧e2)
  A                     B</code></pre>
<p>which means, if we know <code>A ∧ B</code>, we can obtain <code>A</code> or <code>B</code> if we use the elimination rules <code>∧e1</code> or <code>∧e2</code>.</p>
<p>So, if we wanted to prove the conclusion<code>(A ∧ B) ∧ C)</code> from the hypothesis <code>A ∧ (B ∧ C)</code>, we would have to: 1. obtain an <code>A</code> by using <code>∧e1</code> on the hypothesis 2. obtain a <code>B ∧ C</code> by using <code>∧e2</code> on the hypothesis 3. obtain a <code>B</code> by using <code>∧e1</code> on (2) 4. obtain a <code>C</code> by using <code>∧e2</code> on (2) 5. obtain a <code>A ∧ B</code> by using <code>∧i</code> on (1) and (3) 6. reach the conclusion <code>(A ∧ B) ∧ C</code> by using <code>∧i</code> on (5) and (4)</p>
<p>In natural deduction, it looks like this:</p>
<pre><code>A ∧ (B ∧ C)          A ∧ (B ∧ C)
----------- (∧e1)   ------------- (∧e2)
     A                   B ∧ C
     .              --- (∧e1)  --- (∧e2)
     A               B          C
  --------------------- (∧i)    .
          A ∧ B                 C
     ------------------------------- (∧i)
                (A ∧ B) ∧ C</code></pre>
<h2 id="type-theory">Type Theory</h2>
<p>The Curry-Howard correspondence tells us that conjunction translates to pairs in type theory, so we'll switch notation to Haskell's tuple type, using the following notation: - Types: capital letters <code>A</code> <code>B</code> <code>C</code> <code>D</code> - Terms: lowercase letters <code>a</code> <code>b</code> <code>c</code> <code>d</code> - Tuple Types: <code>(A, B)</code> for the tuple <code>A</code> <code>B</code> - Tuple Terms: <code>(a, b)</code> for the tuple <code>a</code> <code>b</code> of type <code>(A, B)</code></p>
<p>Typed lambda calculus has a deduction system as well. Tuple introduction looks very similar to <code>∧i</code>:</p>
<pre><code>  a : A    b : B
------------------ ((,)i)
 (a, b) : (A, B)</code></pre>
<p>which means, given a term <code>a</code> of type <code>A</code> and a term <code>b</code> of type <code>B</code>, then we can obtain a term <code>(a, b)</code> of type <code>(A, B)</code>. Note that we no longer need to say <em>"given we know <code>A</code> and <code>B</code>"</em>, since the existence of a term of each type is enough to form the tuple.</p>
<p>Similarly, there are two elimination rules:</p>
<pre><code>  (a, b) : (A, B)                  (a, b) : (A, B)
------------------- ((,)e1)      ------------------- ((,)e2)
       a : A                            b : B</code></pre>
<p>which means, given a tuple <code>(a, b)</code> of type <code>(A, B)</code> we can obtain a term <code>a</code> or <code>b</code> of type <code>A</code> or <code>B</code>.</p>
<p>If we translate the proposition above, then we have to prove <code>((A, B), C)</code> from <code>(A, (B, C))</code>.</p>
<pre><code>(a, (b, c) : (A, (B, C))          (a, (b, c)) : (A, (B, C))
------------------------ ((,)e1)  ------------------------- ((,)e2)
         a : A                         (b, c) : (B, C)
           .                        ------- ((,)e1) ------- ((,)e2)
         a : A                       b : B           c : C
  ----------------------------------------- ((,)i)     .  
                (a, b) : (A, B)                      c : C
            -------------------------------------------------- ((,)i)
                        ((a, b), c) : ((A, B), C)</code></pre>
<p>The form is identical to the logic proof, except we have terms and the rules use <code>(,)</code> instead of <code>∧</code>.</p>
<h2 id="haskell-proof">Haskell Proof</h2>
<p>We can write the same thing in Haskell:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">assoc ::</span> (a, (b, c)) <span class="ot">-&gt;</span> ((a, b), c)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>assoc (a, (b, c)) <span class="ot">=</span> ((a, b), c)</span></code></pre></div>
<p>However, this takes advantage of a powerful Haskell feature known as pattern matching.</p>
<p>Given the proof above, it's easy to noice that <code>(,)i</code> is exactly the tuple constructor, <code>(,)e1</code> is <code>fst</code> and <code>(,)e2</code> is <code>snd</code>. Knowing this, and looking at the proof above, we could say, given hypothesis <code>h = (a, (b, c)) : (A, (B, C))</code>, we can obtain:</p>
<ol>
<li><code>a : A</code> from <code>fst h</code></li>
<li><code>(b, c) : (B, C)</code> from <code>snd h</code></li>
<li><code>b : B</code> from <code>fst (snd h)</code></li>
<li><code>c : C</code> from <code>snd (snd h)</code></li>
<li><code>(a, b) : (A, B)</code> from <code>(fst h, fst (snd h))</code></li>
<li><code>((a, b), c) : ((A, B), C)</code> from <code>((fst h, fst (snd h)), snd (snd h))</code></li>
</ol>
<p>So, in Haskell:</p>
<pre><code>assoc&#39; :: (a, (b, c)) -&gt; ((a, b), c)
assoc&#39; h = ((fst h, fst (snd h)), snd (snd h))</code></pre>
<p>This is a neat effect of the Curry-Howard correspondence: proofs are programs. So, once we write the proof, we also have the program. We could even write the program and then extract the proof -- it's really the same thing.</p>
<h2 id="category-theory">Category Theory</h2>
<p>The Curry-Howard-Lambek extends the correspondence to include CT as well. The correspondence connects propositions to objects, arrows to implication, conjunction to categorical products, etc.</p>
<p>While in logic we said "given a proof of <code>A</code>", and in type theory we said "given a term of type <code>A</code>", the only way we can do the same in CT is to say "given an arrow from the terminal object <code>T</code> to <code>A</code>, <code>f : T → A</code>". This works because the terminal object represents <code>True</code> / <code>Unit</code> in logic / type theory, so it means "given we can deduce <code>A</code> from <code>True</code>", or "given we can obtain a term <code>a : A</code> from <code>() : ()</code>".</p>
<p>Armed with this, we can now express the same problem in CT terms: - given an arrow <code>h : T → (A × (B × C))</code> - obtain an arrow <code>p : T → ((A × B) × C))</code></p>
<p>Before we begin, let's review what a product is: - given <code>A × B</code>, we know there are two arrows <code>p : A × B → A</code> and <code>q : A × B → B</code>, which we will write as <code>&lt;p, q&gt;</code> - given <code>A × B</code> is the product of <code>A</code> and <code>B</code>, and <code>C</code> is an object with two arrows <code>p' : C → A</code> and <code>q' : C → B</code>, there exists an unique arrow <code>m : C → A × B</code> such that <code>p ∘ m = p'</code> and <code>q ∘ m = q'</code></p>
<p>Also, remember that we can compose any two arrows <code>f : A → B</code> and <code>g : B → C</code> via <code>g ∘ f</code>.</p>
<p>Now we are ready for the proof:</p>
<p><code>T</code> is the terminal object, and <code>t : T → A × (B × C)</code> is what we start with. We need to be able to obtain an arrow <code>t' : T → (A × B) × C)</code>.</p>
<p><img src="/images/curry-howard/ct1.jpg" title="ct1" alt="ct1" /></p>
<p>By <strong>product</strong> <code>A × (B × C)</code>, we know there exists <code>p : A × (B × C) → A</code> and <code>q : A × (B × C) → B × C</code>.</p>
<p>By <strong>composition</strong>, we can obtain the arrows <code>p ∘ t : T → A</code> and <code>q ∘ t : T → B × C</code>.</p>
<p>By <strong>product</strong> <code>B × C</code>, we know there exists <code>p' : B × C → B</code> and <code>q' : B × C → C</code>.</p>
<p>By <strong>composition</strong>, we can obtain the arrow <code>p' ∘ q ∘ t : T → B</code>.</p>
<p>So now, we have the following arrows: - <code>p ∘ t : T → A</code> - <code>p' ∘ q ∘ t : T → B</code></p>
<p><img src="/images/curry-howard/ct2.jpg" title="ct2" alt="ct2" /></p>
<p>By definition of <strong>product</strong>, since we know <code>A × B</code> is the product of <code>A</code> and <code>B</code>, and since we have the arrows <code>T → A</code> and <code>T → B</code>, then we know there must be an unique arrow which we'll name <code>l : T → A × B</code>.</p>
<p>By <strong>composition</strong> we can obtain the arrow <code>q' ∘ q ∘ t : T → C</code>.</p>
<p><img src="/images/curry-howard/ct3.jpg" title="ct3" alt="ct3" /></p>
<p>Similarly to the step before, by definition of <strong>product</strong>, since we know <code>(A × B) × C</code> is a product of <code>A × B</code> and <code>C</code>, and since we have the arrows <code>l : T → A × B</code> and <code>q' ∘ q ∘ t : T → C</code>, then there must exist an unique arrow <code>t' : T → (A × B) × C</code>.</p>
<p>Note: there are, in fact, as many arrows <code>T → (A × B) × C</code> as are elements in <code>(A × B) × C</code>, but <code>t'</code> is the unique one derived from the initial arrow, <code>t</code>.</p>
<p><img src="/images/curry-howard/ct4.jpg" title="ct4" alt="ct4" /></p>
<p>Edit: See this <a href="https://twitter.com/BartoszMilewski/status/1093565646036643841">twitter thread for a whiteboard proof of sum associativity</a>.</p>
<h2 id="back-to-haskell">Back to Haskell</h2>
<p>If we follow the CT arrows as we followed the logic proof: - we could rewrite the <code>l : T → A × B</code> arrow as <code>&lt;i,j&gt; : T → A × B</code>, where <code>i = p ∘ t : T → A</code> and <code>j = p' ∘ q ∘ t : T → B</code>. - we already have <code>k = q' ∘ q ∘ t : T → C</code></p>
<p>So, if instead of <code>t</code> we write <code>a_bc</code> to denote our hypothesis, or inputs, let's look closer at what <code>i</code>, <code>j</code> and <code>k</code> are: - <code>i</code> is <code>p ∘ t</code>, which is the left projection of the premise, or <code>fst a_bc</code></p>
<p>You may ask: Why?!? Well, <code>p ∘ t</code> means <code>p after t</code>. In our case, <code>t</code> represents the input, so it's equivalent to <code>a_bc</code>, and <code>p</code> is the left projection, which is equivalent to <code>fst</code>. Keep in mind that <code>a ∘ b ∘ c</code> means <code>c first, then b, then a</code> when reading the following.</p>
<ul>
<li><code>j</code> is <code>p' ∘ q ∘ t</code>, which is <code>fst (snd a_bc)</code></li>
<li><code>l = &lt;i,j&gt;</code>, so <code>l = (fst a_bc, fst (snd a_bc))</code></li>
<li><code>k</code> is <code>snd (snd a_bc)</code></li>
<li>the result, <code>T → (A × B) × C</code> is <code>&lt; &lt;i,j&gt;, k &gt; = ((fst a_bc, fst (snd a_bc)), snd (snd a_bc))</code></li>
</ul>
<p>If we look back at the Haskell definition: <code>assoc a_bc = ((fst a_bc, fst (snd a_bc)), snd (snd a_bc))</code></p>
<p>Which means we reached the same implementation/proof, again.</p>
<p>Edit: Thank you to <a href="https://twitter.com/BartoszMilewski">Bartosz Milewski</a> and <a href="https://github.com/glmxndr">GhiOm</a> for their <a href="https://github.com/vladciobanu/vladciobanu.github.io/issues/1">early feedback</a>.</p>]]></content>
  </entry>
  <entry>
      <title>Quantifiers in Agda</title>
      <link href="https://cvlad.infoposts/2019-02-17-quantifiers.html"/>
      <id>https://cvlad.infoposts/2019-02-17-quantifiers.html</id>
      <updated>2019-02-17T00:00:SZ</updated>
      <category term="agda"/>
      <category term="dependent types"/>
      <summary>Forall and Exists as Dependent Types</summary>
      <content type="html"><![CDATA[<p>I previously showed a <a href="/curry-howard">single proof</a> in logic, type theory, and category theory, and some fun <a href="/clasical-logic-in-haskell/">classical logic proofs in Haskell</a>, thanks to the Curry-Howard correspondence.</p>
<p>This post will go a bit further than that and show the type theoretic equivalents of existential and universal quantifiers. I'll then explore some interesting properties of these types. This post will not go into the category theory part of this, although I may do that in a future post.</p>
<h2 id="quantifiers-in-logic">Quantifiers in Logic</h2>
<p>Forall (∀) is the universal quantifier and is generally written as</p>
<pre><code>∀ x. P x</code></pre>
<p>where <code>x</code> is a variable and <code>P</code> is a predicate taking such a variable. A basic example of such a proposition could be: <em>"For all numbers x, if you add one to x, you get a greater number than x"</em>, or:</p>
<pre><code>∀ x. x + 1 &gt; x</code></pre>
<p>Similarly, exists (∃) is the existential quantifier and is written as</p>
<pre><code>∃ x. P x</code></pre>
<p>where <code>x</code> is a variable and <code>P</code> is a predicate, for example: <em>"there exists a number that is greater than 10"</em>, or:</p>
<pre><code>∃ x. x &gt; 10</code></pre>
<p>Please note that in classical logic, you can prove an existential proposition by either finding an <code>x</code> for which <code>P(x)</code> is <em>true</em>, or by assuming there does not exist such an <code>x</code> and reaching a contradiction (<a href="https://en.wikipedia.org/wiki/Proof_by_contradiction">proof by contradiction</a>). In <em>intuitionistic</em> logic, the latter is not possible: we have to find the <code>x</code>. One could then say that an existential quantifier in intuitionistic logic is described by a pair of <code>x</code> and <code>P(x)</code>.</p>
<p>In the next chapter, we will look at dependent sum and I will say it's the Curry-Howard correspondent of existential quantifiers. Most theorem provers that rely on this correspondence will use make use of <a href="https://www.cs.cmu.edu/~fp/courses/15317-f08/lectures/08-irrelevance.pdf">proof irrelevance</a> which essentially means that it should not matter whether one picks <code>11</code> or <code>12</code> in order to to prove <code>∃ x. x &gt; 10</code>: the proofs should be equivalent. We will not look into this, nor will we make use of proof irrelevance in this post.</p>
<h2 id="dependent-sum">Dependent Sum</h2>
<p>Dependent sums (Σ) are the type theoretic equivalent of existential quantifiers. In Agda, we can define the dependent sum type as:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> Σ {<span class="dt">A</span> <span class="op">:</span> <span class="dt">Set</span>} (<span class="dt">P</span> <span class="op">:</span> <span class="dt">A</span> <span class="ot">→</span> <span class="dt">Set</span>) <span class="op">:</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    Σ_intro <span class="op">:</span> <span class="ot">∀</span> (a <span class="op">:</span> <span class="dt">A</span>) <span class="ot">→</span> <span class="dt">P</span> a <span class="ot">→</span> Σ <span class="dt">P</span></span></code></pre></div>
<p>The ∑ type is a higher-kinded type which takes a higher-kinded type, <code>P : A → Set</code> -- <code>P</code> takes an <code>A</code> and gives us a new type (<code>Set</code>, in Agda). The nice part about this is that <code>P</code> holds information about both the type of the existential variable (<code>A</code>) as well as the type of the resulting type (<code>P A</code>).</p>
<p>Constructing such a term requires a term of the existential type (<em>evidence</em> for <code>A</code>), and a term of the predicate type (<em>evidence</em> for <code>P A</code>). For example, the example above could be written as <code>∑_intro 11 (11 &gt; 10)</code>, assuming there exists a type <code>&gt;</code> which expresses the greater-than relationship.</p>
<p>Please note that the above example is a simplification and going into the details of how an inductive type for <code>&gt;</code> works is beyond the scope of this post.</p>
<h2 id="dependent-product">Dependent Product</h2>
<p>Dependent products (∏) are the type theoretic equivalent of universal quantifiers. In Agda, we can define the dependent product type as:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> Π {<span class="dt">A</span> <span class="op">:</span> <span class="dt">Set</span>} (<span class="dt">P</span> <span class="op">:</span> <span class="dt">A</span> <span class="ot">→</span> <span class="dt">Set</span>) <span class="op">:</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    Π_intro <span class="op">:</span> (<span class="ot">∀</span> (a <span class="op">:</span> <span class="dt">A</span>) <span class="ot">→</span> <span class="dt">P</span> a) <span class="ot">→</span> Π <span class="dt">P</span></span></code></pre></div>
<p>The ∏ type is also a higher-kinded type. Note that this definition is almost identical to the Σ definition, except for the parantheses used in the constructor (<code>Π_intro</code>). This lines up with the intuition that <code>∀x. P(X)</code> can be described by a function <code>A -&gt; P(x)</code>, where <code>x : A</code>.</p>
<p>Constructing a ∏ type takes a function from the quantified variable to the type described by the predicate.</p>
<p>Constructing a term would, for example be <code>∏_intro (λn. n + 1 &gt; n)</code>.</p>
<h2 id="tuples---special-case-of-dependent-sum">Tuples - Special Case of Dependent Sum</h2>
<p>We will first need to define a <code>constT</code> function:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>constT <span class="op">:</span> <span class="ot">∀</span> (<span class="dt">X</span> <span class="op">:</span> <span class="dt">Set</span>) (<span class="dt">Y</span> <span class="op">:</span> <span class="dt">Set</span>) <span class="ot">→</span> <span class="dt">Y</span> <span class="ot">→</span> <span class="dt">Set</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>constT x _ _ <span class="ot">=</span> x</span></code></pre></div>
<p>This takes two types, <code>X</code> and <code>Y</code>. It then takes a value of type <code>Y</code>, and ignores it, returning the type <code>X</code>.</p>
<p>So, if we take <code>P</code> to <em>not</em> depend on the quantified item and define it using <code>constT</code>, then we can obtain tuples in the case of ∑ types:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>Σ<span class="op">-</span>pair <span class="op">:</span> <span class="ot">∀</span> (<span class="dt">A</span> <span class="dt">B</span> <span class="op">:</span> <span class="dt">Set</span>) <span class="ot">→</span> <span class="dt">Set</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>Σ<span class="op">-</span>pair a b <span class="ot">=</span> Σ (constT b a)</span></code></pre></div>
<p>Note that <code>Σ-pair</code> is a type-level function that takes two types and returns the type of pairs.</p>
<p>We can then define a simple pair constructor using the constructor above:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>Σ<span class="op">-</span>mkPair <span class="op">:</span> <span class="ot">∀</span> {<span class="dt">A</span> <span class="op">:</span> <span class="dt">Set</span>}  {<span class="dt">B</span> <span class="op">:</span> <span class="dt">Set</span>} <span class="ot">→</span> <span class="dt">A</span> <span class="ot">→</span> <span class="dt">B</span> <span class="ot">→</span> Σ<span class="op">-</span>pair <span class="dt">A</span> <span class="dt">B</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>Σ<span class="op">-</span>mkPair a b <span class="ot">=</span> Σ_intro a b</span></code></pre></div>
<p>And we can have the two projections by simple pattern match, returning the appropriate value:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>Σ<span class="op">-</span><span class="fu">fst</span> <span class="op">:</span> <span class="ot">∀</span> {<span class="dt">A</span> <span class="dt">B</span> <span class="op">:</span> <span class="dt">Set</span>} <span class="ot">→</span> Σ<span class="op">-</span>pair <span class="dt">A</span> <span class="dt">B</span> <span class="ot">→</span> <span class="dt">A</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>Σ<span class="op">-</span><span class="fu">fst</span> (Σ_intro a _) <span class="ot">=</span> a</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>Σ<span class="op">-</span><span class="fu">snd</span> <span class="op">:</span> <span class="ot">∀</span> {<span class="dt">A</span> <span class="dt">B</span> <span class="op">:</span> <span class="dt">Set</span>} <span class="ot">→</span> Σ<span class="op">-</span>pair <span class="dt">A</span> <span class="dt">B</span> <span class="ot">→</span> <span class="dt">B</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>Σ<span class="op">-</span><span class="fu">snd</span> (Σ_intro _ b) <span class="ot">=</span> b</span></code></pre></div>
<p>This works because Σ types are defined as <code>a -&gt; P a -&gt; Σ P</code>, so if we take a <code>P</code> such that <code>P a</code> always is <code>b</code>, then we get <code>a -&gt; b -&gt; Σ</code> which is essentially a tuple of <code>a</code> and <code>b</code>.</p>
<p>We can now say <code>Σ_snd (Σ_mkPair 1 2)</code> and get the result <code>2</code>.</p>
<h2 id="functions---special-case-of-dependent-product">Functions - Special Case of Dependent Product</h2>
<p>Similarly, if we take <code>P</code> to be <code>const B A</code>, we can obtain functions out of ∏ types:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>Π<span class="op">-</span>function <span class="op">:</span> <span class="ot">∀</span> (<span class="dt">A</span> <span class="dt">B</span> <span class="op">:</span> <span class="dt">Set</span>) <span class="ot">→</span> <span class="dt">Set</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>Π<span class="op">-</span>function a b <span class="ot">=</span> Π (constT b a)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>Π<span class="op">-</span>mkFunction <span class="op">:</span> <span class="ot">∀</span> {<span class="dt">A</span> <span class="dt">B</span> <span class="op">:</span> <span class="dt">Set</span>} <span class="ot">→</span> (<span class="dt">A</span> <span class="ot">→</span> <span class="dt">B</span>) <span class="ot">→</span> Π<span class="op">-</span>function <span class="dt">A</span> <span class="dt">B</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>Π<span class="op">-</span>mkFunction f <span class="ot">=</span> Π_intro f</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>Π<span class="op">-</span>apply <span class="op">:</span> <span class="ot">∀</span> {<span class="dt">A</span> <span class="dt">B</span> <span class="op">:</span> <span class="dt">Set</span>} <span class="ot">→</span> Π<span class="op">-</span>function <span class="dt">A</span> <span class="dt">B</span> <span class="ot">→</span> <span class="dt">A</span> <span class="ot">→</span> <span class="dt">B</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>Π<span class="op">-</span>apply (Π_intro f) a <span class="ot">=</span> f a</span></code></pre></div>
<p>As with sum types, this works because Π types are defined as <code>(a -&gt; P a) -&gt; Π P</code>, so if we take <code>P</code> such that <code>P a</code> always is <code>b</code>, then we get <code>(a -&gt; b) -&gt; Π</code>, which is essentially a function from <code>a</code> to <code>b</code>.</p>
<p>We can now write <code>Π-apply (Π-mkFunction (λx. x + 1)) 1</code> and get the result <code>2</code>.</p>
<h2 id="what-about-sum-types">What About Sum Types?</h2>
<p>We can obtain sum types from ∑ types by using <code>Bool</code> as the variable type, and the predicate <em>returning</em> type <code>A</code> for <code>true</code>, and type <code>B</code> for <code>false</code>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>bool <span class="op">:</span> <span class="ot">∀</span> (<span class="dt">A</span> <span class="dt">B</span> <span class="op">:</span> <span class="dt">Set</span>) <span class="ot">→</span> <span class="dt">Bool</span> <span class="ot">→</span> <span class="dt">Set</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>bool a _ true  <span class="ot">=</span> a</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>bool _ b false <span class="ot">=</span> b</span></code></pre></div>
<p>Note that <code>a</code> and <code>b</code> are types! We can now write:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>Σ<span class="op">-</span><span class="fu">sum</span> <span class="op">:</span> <span class="ot">∀</span> (<span class="dt">A</span> <span class="dt">B</span> <span class="op">:</span> <span class="dt">Set</span>) <span class="ot">→</span> <span class="dt">Set</span> </span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>Σ<span class="op">-</span><span class="fu">sum</span> a b <span class="ot">=</span> Σ (bool a b)</span></code></pre></div>
<p>Now, in order to construct such a type (via <em>left</em> or <em>right</em>), we just need to pass the appropriate boolean value along with an item of the correct type:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>Σ<span class="op">-</span>sum_left <span class="op">:</span> <span class="ot">∀</span> {<span class="dt">A</span> <span class="op">:</span> <span class="dt">Set</span>} (<span class="dt">B</span> <span class="op">:</span> <span class="dt">Set</span>) <span class="ot">→</span> <span class="dt">A</span> <span class="ot">→</span> Σ<span class="op">-</span><span class="fu">sum</span> <span class="dt">A</span> <span class="dt">B</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>Σ<span class="op">-</span>sum_left _ a <span class="ot">=</span> Σ_intro true a</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>Σ<span class="op">-</span>sum_right <span class="op">:</span> <span class="ot">∀</span> {<span class="dt">B</span> <span class="op">:</span> <span class="dt">Set</span>} (<span class="dt">A</span> <span class="op">:</span> <span class="dt">Set</span>) <span class="ot">→</span> <span class="dt">B</span> <span class="ot">→</span> Σ<span class="op">-</span><span class="fu">sum</span> <span class="dt">A</span> <span class="dt">B</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>Σ<span class="op">-</span>sum_right _ b <span class="ot">=</span> Σ_intro false b</span></code></pre></div>
<p>Eliminating is just a matter of pattern matching on the boolean value and applying the correct function:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>Σ<span class="op">-</span>sum_elim <span class="op">:</span> <span class="ot">∀</span> {<span class="dt">A</span> <span class="dt">B</span> <span class="dt">R</span> <span class="op">:</span> <span class="dt">Set</span>} <span class="ot">→</span> (<span class="dt">A</span> <span class="ot">→</span> <span class="dt">R</span>) <span class="ot">→</span> (<span class="dt">B</span> <span class="ot">→</span> <span class="dt">R</span>) <span class="ot">→</span> Σ<span class="op">-</span><span class="fu">sum</span> <span class="dt">A</span> <span class="dt">B</span> <span class="ot">→</span> <span class="dt">R</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>Σ<span class="op">-</span>sum_elim f _ (Σ_intro true  a) <span class="ot">=</span> f a</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>Σ<span class="op">-</span>sum_elim _ g (Σ_intro false b) <span class="ot">=</span> g b</span></code></pre></div>
<p>As an example, <code>Σ-sum_elim (const "left") (const "right") (Σ-sum_left Bool 1)</code>, and get the result <code>"left"</code>.</p>
<p>Interestingly, we can also obtain sum types from ∏ types: the idea is to encode the eliminator right into our type! For that we will need the following predicate:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>prodPredicate <span class="op">:</span> <span class="ot">∀</span> (<span class="dt">A</span> <span class="dt">B</span> <span class="dt">R</span> <span class="op">:</span> <span class="dt">Set</span>) <span class="ot">→</span> <span class="dt">Set</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>prodPredicate a b r <span class="ot">=</span> (a <span class="ot">→</span> r) <span class="ot">→</span> (b <span class="ot">→</span> r) <span class="ot">→</span> r</span></code></pre></div>
<p>This means that given two types <code>A</code> and <code>B</code>, we get a type-level function from <code>R</code> to <code>(A -&gt; R) -&gt; (B -&gt; R) -&gt; R</code>, which is exactly the eliminator type. Don't worry about <code>Set₁</code> or <code>Π'</code> for now:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>Π<span class="op">-</span><span class="fu">sum</span> <span class="op">:</span> <span class="ot">∀</span> (<span class="dt">A</span> <span class="dt">B</span> <span class="op">:</span> <span class="dt">Set</span>) <span class="ot">→</span> <span class="dt">Set</span>₁</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>Π<span class="op">-</span><span class="fu">sum</span> a b <span class="ot">=</span> Π<span class="ch">&#39; (prodPredicate a b)</span></span></code></pre></div>
<p>This means that in order to build a sum type, we need to pass a type <code>R</code> and a function <code>(A -&gt; R) -&gt; (B -&gt; R) -&gt; R</code>. So, the constructors will look like:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>Π<span class="op">-</span><span class="fu">sum</span><span class="op">-</span>left <span class="op">:</span> <span class="ot">∀</span> {<span class="dt">A</span> <span class="op">:</span> <span class="dt">Set</span>} (<span class="dt">B</span> <span class="op">:</span> <span class="dt">Set</span>) <span class="ot">→</span> <span class="dt">A</span> <span class="ot">→</span> Π<span class="op">-</span><span class="fu">sum</span> <span class="dt">A</span> <span class="dt">B</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>Π<span class="op">-</span><span class="fu">sum</span><span class="op">-</span>left _ a <span class="ot">=</span> Π<span class="ch">&#39;_intro (\_ f _ → f a)</span></span></code></pre></div>
<p>The lambda is the only interesting bit: we construct a function that given a type <code>R</code> (first <code>_</code>) and a function <code>A -&gt; R</code> (named <code>f</code>), we can return an <code>R</code> by calling <code>f a</code> (the third <code>_</code> parameter is for the function <code>g : B -&gt; R</code>, which is not required for the <em>left</em> constructor).</p>
<p>Similarly, we can write a constructor for <em>right</em>:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>Π<span class="op">-</span><span class="fu">sum</span><span class="op">-</span>right <span class="op">:</span> <span class="ot">∀</span> {<span class="dt">A</span> <span class="op">:</span> <span class="dt">Set</span>} (<span class="dt">B</span> <span class="op">:</span> <span class="dt">Set</span>) <span class="ot">→</span> <span class="dt">B</span> <span class="ot">→</span> Π<span class="op">-</span><span class="fu">sum</span> <span class="dt">A</span> <span class="dt">B</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>Π<span class="op">-</span><span class="fu">sum</span><span class="op">-</span>right _ b <span class="ot">=</span> Π<span class="ch">&#39;_intro (\_ _ g → g b)</span></span></code></pre></div>
<p>As for the eliminator, we simply require the two functions <code>A -&gt; R</code> and <code>B -&gt; R</code> in order to pass to our dependent product and get an <code>R</code>:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>Π<span class="op">-</span><span class="fu">sum</span><span class="op">-</span>elim <span class="op">:</span> <span class="ot">∀</span> {<span class="dt">A</span> <span class="dt">B</span> <span class="dt">R</span> <span class="op">:</span> <span class="dt">Set</span>} <span class="ot">→</span> (<span class="dt">A</span> <span class="ot">→</span> <span class="dt">R</span>) <span class="ot">→</span> (<span class="dt">B</span> <span class="ot">→</span> <span class="dt">R</span>) <span class="ot">→</span> Π<span class="op">-</span><span class="fu">sum</span> <span class="dt">A</span> <span class="dt">B</span> <span class="ot">→</span> <span class="dt">R</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>Π<span class="op">-</span><span class="fu">sum</span><span class="op">-</span>elim f g (Π<span class="ch">&#39;_intro elim) = elim _ f g</span></span></code></pre></div>
<h2 id="conclusions">Conclusions</h2>
<p>We've used three type-level functions to generate a few interesting types:</p>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Σ-type</th>
<th>Π-type</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>constT</td>
<td>tuple</td>
<td>function</td>
</tr>
<tr class="even">
<td>bool</td>
<td>either</td>
<td>tuple</td>
</tr>
<tr class="odd">
<td>prodPredicate</td>
<td>-</td>
<td>either</td>
</tr>
</tbody>
</table>
<p>What other interesting type-level functions can you find for Σ and/or Π types?</p>
<p>You can find the <a href="/content/quantifiers/DT.agda">source file here</a>.</p>]]></content>
  </entry>
  <entry>
      <title>Functor-Of</title>
      <link href="https://cvlad.infoposts/2019-05-12-functor-of.html"/>
      <id>https://cvlad.infoposts/2019-05-12-functor-of.html</id>
      <updated>2019-05-12T00:00:SZ</updated>
      <category term="haskell"/>
      <category term="functor"/>
      <summary>Towards a more general Functor class</summary>
      <content type="html"><![CDATA[<p>Due to kind restrictions, the Haskell <em>Functor</em> cannot represent a lot of valid functors: functors of higher kinded types (higher than <code>* -&gt; *</code>), contravariant functors, invariant functors, etc.</p>
<p>This post will show an alternate <code>Functor</code> that can handle all of the above. I got this idea from the awesome <a href="https://twitter.com/am_i_tom">Tom Harding</a>, and he apparently got it from <a href="https://twitter.com/Iceland_jack">@Iceland_jack</a>.</p>
<p>Although this is not new, I could not find any blog post or paper covering it.</p>
<h2 id="the-actual-problem">The actual problem</h2>
<p>The problem is quite straight-forward. Let's say we want to define a functor instance for <code>(a, b)</code> which changes the <code>a</code>, to <code>c</code> using an <code>a -&gt; c</code> function. This should be possible, but there is no way to write it using <code>Functor</code> and <code>fmap</code>.</p>
<p>There are two ways to do this in Haskell using <code>Prelude</code>: - by using <code>Bifunctor</code>/<code>first</code>, or - by using the <code>Flip</code> newtype.</p>
<p>While both the above options work, they are not particularly elegant. On top of that, there is no common <em>Trifunctor</em> package, and flipping arguments around and wrapping/unwrapping newtypes is not very appealing, which means the approach doesn't quite scale well.</p>
<h2 id="functorof-to-the-rescue">FunctorOf to the rescue</h2>
<p>There are two problems with <code>Functor</code>: - <code>f</code> has the wrong kind if we want to allow higher kinded functors, and - the arrow of the mapped function is the wrong type if we want to allow contravariant or invariant functors (or even other types of mappings!).</p>
<p>We can fix both problems by adding additional types to the class:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">FunctorOf</span> (<span class="ot">p ::</span> k <span class="ot">-&gt;</span> k <span class="ot">-&gt;</span> <span class="dt">Type</span>) (<span class="ot">q ::</span> l <span class="ot">-&gt;</span> l <span class="ot">-&gt;</span> <span class="dt">Type</span>) f <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  map ::</span> p a b <span class="ot">-&gt;</span> q (f a) (f b)</span></code></pre></div>
<p><code>p</code> represents a relationshiop (arrow) between <code>a</code> and <code>b</code>. In case of a regular functor, it's just <code>-&gt;</code>, but we can change it to a reverse arrow for contravariants.</p>
<p><code>q</code> is normally just an optional layer on top of <code>-&gt;</code>, in order to allow mapping over other arguments. For example, if we want to map over the second-to-last argument, we'd use natural transforms (<code>~&gt;</code>).</p>
<p>The regular functor instance can be obtained by simply:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">FunctorOf</span> (<span class="ot">-&gt;</span>) (<span class="ot">-&gt;</span>) f <span class="kw">where</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  map ::</span> <span class="kw">forall</span> a b<span class="op">.</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">map</span> <span class="ot">=</span> <span class="fu">fmap</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="ot">functorExample ::</span> [<span class="dt">String</span>]</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>functorExample <span class="ot">=</span> <span class="fu">map</span> <span class="fu">show</span> ([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>]<span class="ot"> ::</span> [<span class="dt">Int</span>])</span></code></pre></div>
<h2 id="functor-for-hkd">Functor for HKD</h2>
<p>I'll use the <code>Bifunctor</code> instance in order to show all bifunctors can have such a <code>FunctorOf</code> instance. Of course, one could define instances manually for any <code>Bifunctor</code>.</p>
<p>Going back to our original example, we can define a <code>FunctorOf</code> instance for <code>* -&gt; * -&gt; *</code> types in the first argument via:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> (<span class="op">~&gt;</span>) f g <span class="ot">=</span> <span class="dt">Natural</span> (<span class="kw">forall</span> x<span class="op">.</span> f x <span class="ot">-&gt;</span> g x)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Bifunctor</span> f <span class="ot">=&gt;</span> <span class="dt">FunctorOf</span> (<span class="ot">-&gt;</span>) (<span class="op">~&gt;</span>) f <span class="kw">where</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  map ::</span> <span class="kw">forall</span> a b<span class="op">.</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="op">~&gt;</span> f b</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">map</span> f <span class="ot">=</span> <span class="dt">Natural</span> <span class="op">$</span> first f</span></code></pre></div>
<p>In order to avoid fiddling about with newtypes, we can define a helper <code>bimap'</code> function for <code>* -&gt; * -&gt; *</code> that maps both arguments:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>bimap&#39;</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> <span class="kw">forall</span> a b c d f</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span>  <span class="dt">FunctorOf</span> (<span class="ot">-&gt;</span>) (<span class="ot">-&gt;</span>) (f a)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=&gt;</span> <span class="dt">FunctorOf</span> (<span class="ot">-&gt;</span>) (<span class="op">~&gt;</span>) f</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b)</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> d)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> f a c</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> f b d</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>bimap&#39; f g fac <span class="ot">=</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> <span class="fu">map</span> f <span class="kw">of</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Natural</span> a2b <span class="ot">-&gt;</span> a2b (<span class="fu">map</span> g fac)</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="ot">bifunctorExample ::</span> (<span class="dt">String</span>, <span class="dt">String</span>)</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>bifunctorExample <span class="ot">=</span> bimap&#39; <span class="fu">show</span> <span class="fu">show</span> (<span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span>, <span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span>)</span></code></pre></div>
<h2 id="contravariant">Contravariant</h2>
<p>Okay, cool. But what about <em>contravariant</em> functors? We can use <code>Op</code> from <code>Data.Functor.Contravariant</code> (defined as <code>data Op a b = Op (b -&gt; a)</code>):</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Contravariant</span> f <span class="ot">=&gt;</span> <span class="dt">FunctorOf</span> <span class="dt">Op</span> (<span class="ot">-&gt;</span>) f <span class="kw">where</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  map ::</span> <span class="kw">forall</span> a b<span class="op">.</span> (<span class="dt">Op</span> b a) <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f a</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">map</span> (<span class="dt">Op</span> f) <span class="ot">=</span> contramap f</span></code></pre></div>
<p>This is pretty cool since we only need to change the mapped function's type to be <code>Op</code> instead of <code>-&gt;</code>! As before, we can make things easier by defining a helper:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>cmap</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> <span class="kw">forall</span> a b f</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span>  <span class="dt">FunctorOf</span> <span class="dt">Op</span> (<span class="ot">-&gt;</span>) f</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> a)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> f a</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> f b</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>cmap f fa <span class="ot">=</span> <span class="fu">map</span> (<span class="dt">Op</span> f) fa</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="ot">contraExample ::</span> <span class="dt">Predicate</span> <span class="dt">Int</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>contraExample <span class="ot">=</span> cmap <span class="fu">show</span> (<span class="dt">Predicate</span> (<span class="op">==</span> <span class="st">&quot;5&quot;</span>))</span></code></pre></div>
<h2 id="what-about-profunctors">What about Profunctors?</h2>
<p>I'm glad you asked! It's as easy as 1-2-3, or well, as easy as "functor in the last argument" - "contravariant in the previous" - "write helper function":</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Profunctor</span> p <span class="ot">=&gt;</span> <span class="dt">FunctorOf</span> <span class="dt">Op</span> (<span class="op">~&gt;</span>) p <span class="kw">where</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  map ::</span> <span class="kw">forall</span> a b<span class="op">.</span> (<span class="dt">Op</span> b a) <span class="ot">-&gt;</span> p b <span class="op">~&gt;</span> p a</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">map</span> (<span class="dt">Op</span> f) <span class="ot">=</span> <span class="dt">Natural</span> <span class="op">$</span> lmap f</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>dimap&#39;</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> <span class="kw">forall</span> a b c d p</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span>  <span class="dt">FunctorOf</span> (<span class="ot">-&gt;</span>) (<span class="ot">-&gt;</span>) (p a)</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=&gt;</span> <span class="dt">FunctorOf</span> <span class="dt">Op</span>   (<span class="op">~&gt;</span>) p</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> a)</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> d)</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> p a c</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> p b d</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>dimap&#39; f g pac <span class="ot">=</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> <span class="fu">map</span> (<span class="dt">Op</span> f) <span class="kw">of</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Natural</span> b2a <span class="ot">-&gt;</span> b2a (<span class="fu">map</span> g pac)</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a><span class="ot">profunctorExample ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>profunctorExample <span class="ot">=</span> dimap&#39; <span class="fu">read</span> <span class="fu">show</span> (<span class="op">+</span> (<span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span>))</span></code></pre></div>
<h2 id="trifunctors">Tri..functors?</h2>
<p>Yep. We only need to define a higher-kinded natural transform and write the <code>FunctorOf</code> instance, along with the helper:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> (<span class="op">~~&gt;</span>) f g <span class="ot">=</span> <span class="dt">NatNat</span> (<span class="kw">forall</span> x<span class="op">.</span> f x <span class="op">~&gt;</span> g x)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Triple</span> a b c <span class="ot">=</span> <span class="dt">Triple</span> a b c <span class="kw">deriving</span> (<span class="dt">Functor</span>)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="ot">{-# overlapping #-}</span> <span class="dt">FunctorOf</span> (<span class="ot">-&gt;</span>) (<span class="op">~&gt;</span>) (<span class="dt">Triple</span> x) <span class="kw">where</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="ot">  map ::</span> <span class="kw">forall</span> a b<span class="op">.</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Triple</span> x a <span class="op">~&gt;</span> <span class="dt">Triple</span> x b</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">map</span> f <span class="ot">=</span> <span class="dt">Natural</span> <span class="op">$</span> \(<span class="dt">Triple</span> x a y) <span class="ot">-&gt;</span> <span class="dt">Triple</span> x (f a) y</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">FunctorOf</span> (<span class="ot">-&gt;</span>) (<span class="op">~~&gt;</span>) <span class="dt">Triple</span> <span class="kw">where</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="ot">  map ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Triple</span> a <span class="op">~~&gt;</span> <span class="dt">Triple</span> b</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">map</span> f <span class="ot">=</span> <span class="dt">NatNat</span> <span class="op">$</span> <span class="dt">Natural</span> <span class="op">$</span> \(<span class="dt">Triple</span> a x y) <span class="ot">-&gt;</span> <span class="dt">Triple</span> (f a) x y</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>triple</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> <span class="kw">forall</span> a b c d e f t</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span>  <span class="dt">FunctorOf</span> (<span class="ot">-&gt;</span>) (<span class="ot">-&gt;</span>)  (t a c)</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=&gt;</span> <span class="dt">FunctorOf</span> (<span class="ot">-&gt;</span>) (<span class="op">~&gt;</span>)  (t a)</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=&gt;</span> <span class="dt">FunctorOf</span> (<span class="ot">-&gt;</span>) (<span class="op">~~&gt;</span>) t</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b)</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> d)</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> (e <span class="ot">-&gt;</span> f)</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> t a c e</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> t b d f</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>triple f g h <span class="ot">=</span> a2b <span class="op">.</span> c2d <span class="op">.</span> <span class="fu">map</span> h</span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">Natural</span> c2d) <span class="ot">=</span> <span class="fu">map</span> g</span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">NatNat</span> (<span class="dt">Natural</span> a2b)) <span class="ot">=</span> <span class="fu">map</span> f</span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a><span class="ot">tripleExample ::</span> <span class="dt">Triple</span> <span class="dt">String</span> <span class="dt">String</span> <span class="dt">String</span></span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a>tripleExample <span class="ot">=</span> triple <span class="fu">show</span> <span class="fu">show</span> <span class="fu">show</span> (<span class="dt">Triple</span> (<span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span>) (<span class="dv">2</span><span class="ot"> ::</span> <span class="dt">Int</span>) (<span class="dv">3</span><span class="ot"> ::</span> <span class="dt">Int</span>))</span></code></pre></div>
<p>The pattern is pretty simple: - we need a <code>FunctorOf</code> instance for every argument we want to map - for each such argument, we need to use <code>-&gt;</code> for variant and <code>Op</code> for contravariant arguments as the first argument to <code>FunctorOf</code> - from right to left, we need to use increasing level of transforms to map the type arguments (<code>-&gt;</code>, <code>~&gt;</code>, <code>~~&gt;</code>, etc)</p>
<h2 id="what-about-invariants">What about invariants?</h2>
<p>We can define an instance for <code>Endo</code> using:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Iso</span> a b <span class="ot">=</span> <span class="dt">Iso</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> to   ::</span> a <span class="ot">-&gt;</span> b</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> from ::</span> b <span class="ot">-&gt;</span> a</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">FunctorOf</span> <span class="dt">Iso</span> (<span class="ot">-&gt;</span>) <span class="dt">Endo</span> <span class="kw">where</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="ot">  map ::</span> <span class="kw">forall</span> a b<span class="op">.</span> <span class="dt">Iso</span> a b <span class="ot">-&gt;</span> <span class="dt">Endo</span> a <span class="ot">-&gt;</span> <span class="dt">Endo</span> b</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">map</span> <span class="dt">Iso</span> { to, from } (<span class="dt">Endo</span> f) <span class="ot">=</span> <span class="dt">Endo</span> <span class="op">$</span> to <span class="op">.</span> f <span class="op">.</span> from</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="ot">endoExample ::</span> <span class="dt">Endo</span> <span class="dt">String</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>endoExample <span class="ot">=</span> <span class="fu">map</span> (<span class="dt">Iso</span> <span class="fu">show</span> <span class="fu">read</span>) (<span class="dt">Endo</span> (<span class="op">+</span> (<span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span>)))</span></code></pre></div>
<p>We can even go further:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">FunctorOf</span> (<span class="ot">-&gt;</span>) (<span class="ot">-&gt;</span>) f <span class="ot">=&gt;</span> <span class="dt">FunctorOf</span> <span class="dt">Iso</span> <span class="dt">Iso</span> f <span class="kw">where</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  map ::</span> <span class="dt">Iso</span> a b <span class="ot">-&gt;</span> <span class="dt">Iso</span> (f a) (f b)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">map</span> <span class="dt">Iso</span> { to, from } <span class="ot">=</span> <span class="dt">Iso</span> (<span class="fu">map</span> to) (<span class="fu">map</span> from)</span></code></pre></div>
<p>which is to say, given an isomorphism between <code>a</code> and <code>b</code>, we can obtain an isomorphism between <code>f a</code> and <code>f b</code>!</p>
<h2 id="future-work-ideas">Future work ideas</h2>
<p>I think this instance can be also used for proofs. For example, using the <code>Refl</code> equality type:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> x <span class="op">:~:</span> y <span class="kw">where</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Refl</span><span class="ot"> ::</span> x <span class="op">:~:</span> x</span></code></pre></div>
<p>And this means we can write transitivity as:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">FunctorOf</span> (<span class="op">:~:</span>) (<span class="ot">-&gt;</span>) ((<span class="op">:~:</span>) x) <span class="kw">where</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  map ::</span> <span class="kw">forall</span> a b<span class="op">.</span> a <span class="op">:~:</span> b <span class="ot">-&gt;</span> x <span class="op">:~:</span> a <span class="ot">-&gt;</span> x <span class="op">:~:</span> b</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">map</span> <span class="dt">Refl</span> <span class="dt">Refl</span> <span class="ot">=</span> <span class="dt">Refl</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="ot">proof ::</span> <span class="dt">Int</span> <span class="op">:~:</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="op">:~:</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="op">:~:</span> <span class="dt">String</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>proof <span class="ot">=</span> <span class="fu">map</span></span></code></pre></div>
<p>Code is available <a href="https://github.com/vladciobanu/functorof/blob/master/src/FunctorOf.hs">here</a>.</p>
<p>Another thing worth mentioning is the awesome upcoming <a href="https://gitlab.haskell.org/kcsongor/ghc/tree/unsaturated_type_families">GHC extension</a> (being worked on by <a href="https://twitter.com/Lowert">Csongor Kiss</a>) which allows type families to be partially applied. If you haven't <a href="https://www.microsoft.com/en-us/research/publication/higher-order-type-level-programming-in-haskell/">read the paper</a>, you should! Using this feature, one could do something like:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">Id</span> a <span class="kw">where</span> <span class="dt">Id</span> x <span class="ot">=</span> x</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">FunctorOf</span> (<span class="ot">-&gt;</span>) (<span class="ot">-&gt;</span>) <span class="dt">Id</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">map</span> <span class="ot">=</span> (<span class="op">$</span>)</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="ot">idExample ::</span> <span class="dt">Bool</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>idExample <span class="ot">=</span> <span class="fu">map</span> (<span class="op">+</span><span class="dv">1</span>) <span class="dv">1</span> <span class="op">==</span> <span class="dv">2</span></span></code></pre></div>
<p>Please note I have not tested the above code; it was suggested by Tom Harding (thanks again for the idea and reviewing!).</p>
<p>What other uses can you come up with?</p>]]></content>
  </entry>
  <entry>
      <title>Hire and Train Haskell Junior Developers</title>
      <link href="https://cvlad.infoposts/2019-12-30-junior-developers.html"/>
      <id>https://cvlad.infoposts/2019-12-30-junior-developers.html</id>
      <updated>2019-12-30T00:00:SZ</updated>
      <category term="personal"/>
      <category term="fp"/>
      <category term="haskell"/>
      <summary>A plea to senior developers and team leads</summary>
      <content type="html"><![CDATA[<p>I think the reason we don't have more people doing Haskell is we're not actually hiring junior developers, and when we do, we don't set them up for success by properly training them.</p>
<h2 id="introduction">Introduction</h2>
<p>This post was sparked by a few other posts in the Haskell world. They are, to my knowledge, in chronological order:</p>
<ul>
<li>Michal Snoyman's <a href="https://www.snoyman.com/blog/2019/11/boring-haskell-manifesto">Boring Haskell Manifesto</a></li>
<li>Matt Parsons' <a href="https://www.parsonsmatt.org/2019/12/26/write_junior_code.html">Write Junior Code</a></li>
<li>Marco Sampellegrini's <a href="https://alpacaaa.net/thoughts-on-haskell-2020/">My thoughts on Haskell in 2020</a></li>
</ul>
<p>Snoyman's manifesto is a call to define a safe subset of the Haskell language and common libraries, provide documentation, tutorials, cookbooks, and continuously evolve, update, and help engineers use and get "boring Haskell" adopted.</p>
<p>Parsons notes that Haskell has a hiring problem: there are few jobs, and most of those are for senior developers. The reason for this is that we over-indulge in fancy Haskell, making our code needlessly complicated. If we wrote simple, junior-level Haskell, we would be able to hire junior developers and have them be productive.</p>
<p>Sampellegrini's post points out a few key problems:</p>
<ul>
<li>there's a lot of extensions we need to keep track of, which makes things hard</li>
<li>if an idea looks good on paper, it doesn't mean it's going to be easy to maintain in the long run</li>
<li>inclusivity might be a problem: "I don't want a PhD to be a requirement to work with Haskell"</li>
<li>they argue there's marginal benefit to fancy types/Haskell</li>
</ul>
<p>While I understand where all of these feelings are coming from, and I agree to some of the ideas, I think they have their marks on the wrong problem.</p>
<h2 id="the-real-problem">The Real Problem</h2>
<p>I think the real problem is that we are not putting up jobs for junior devs. We're not even giving them a chance. And when we are, we usually don't give them enough support (through training and making sure they know who to ask, and that it's okay to do so) to succeed.</p>
<p>I'm really not sure why we're not hiring more junior developers. It might be because seniors like to think that the code they are writing is so complicated that a junior would take too long to be able to understand, so they advise management that a junior cannot possibly be productive. Maybe it's because they don't want to be bothered with training junior devs, and they would rather just work on code instead? Or maybe it's because management doesn't like seniors' time being "wasted" on teaching junior devs?</p>
<p>Whatever the reason, I don't really think writing simpler code will help much. If the on-boarding process is lacking, if the company culture is not welcoming to junior devs, most of them will be set for failure from the get-go, regardless of how fancy or simple the code is.</p>
<h2 id="junior-developers">Junior Developers</h2>
<p>What is a junior developer? For the purposes of this article, I will define a Haskell junior developer as somebody who's able to confidently use simple monads like <code>Maybe</code>, <code>Either e</code>, <code>IO</code>, and the list monad. Ideally, they would also have a crude understanding of monad transformers (but not necessarily <code>mtl</code> as well). They are able to compose functions, reason about ADTs, and, perhaps most importantly, are motivated to learn more about Haskell and FP.</p>
<p>I currently work on two projects, both in Haskell. One of these projects has two junior Haskell developers, and the other has one. I will briefly go over the details of these projects as well as my mentoring experience in order to establish a baseline.</p>
<p>I have not been working with Haskell for very long. I actually come from OOP-land (you can <a href="https://cvlad.info/haskell/">read my story here</a>), and I have a lot of experience as a team lead. I have hired, trained, and mentored a decent number of junior devs, most of them in my OOP days, but also three of them recently, at the place I currently work. For the past year and a half, I have been the main developer in charge of training and making sure the junior devs are productive.</p>
<p>Our codebases (you can <a href="https://github.com/kframework/kore">see one of them here</a>) are pretty complicated: besides the fact that they use notoriously complex Haskell libraries such as <code>lens</code>, <code>servant</code>, and <code>recursion-schemes</code>, the domain problem is pretty complicated as well: we're essentially building an automated prover for a rewrite-based executable semantic framework (the other project is a pretty standard servant app, so not too much to go over there, although it does use <code>lens</code>, <code>generic-lens</code>, <code>persistent</code>/<code>esqueleto</code> and obviously <code>servant</code>).</p>
<p>This prelude was needed because I can't really speak about junior developers in general, but I can tell you about my experience with on-boarding junior Haskell developers on our projects. However, before that, I would like to add that the junior devs we hired were all either senior year at the local university, or fresh graduates. They were picked because they are all excited about FP, despite the fact that none of them had any previous professional experience related to FP or Haskell.</p>
<p>I am proud to say that all three junior devs are doing great. I obviously can't take any significant part of the credit (they are all very smart and hard working), but I think that there are a few things that contributed to their success:</p>
<ul>
<li><strong>Kindness</strong> we've all gone through this. We're all trying our best. Be kind and supportive. Praise them when they do a good job. Encourage them to come up with ideas and to bring their ideas forward.</li>
<li><strong>Confidence</strong> make sure they know it's okay to not know things; there's a ton of things I don't know, and I make sure to be loud about it. I also make sure to show them how I find the answers to things I don't know. Of course, on top of literally telling them it's okay to ask questions and not know stuff, even if it feels like it's something they should know (there's no such thing, really: we all have our blind spots).</li>
<li><strong>Support</strong> be there for them. We have daily meetings and we make sure we know what everybody's up to. We make sure to ask everybody if they're stuck or not, if they need help or more work.</li>
<li><strong>Training</strong> at least until they get comfortable, make sure you go over the things that are "fancy" in the codebase. At the very least, make sure you go over a few examples and show them how it works. Make sure they understand. A few exercises where you work together can be particularly useful as well.</li>
<li><strong>Clarity</strong> it is vitally important that tasks are as crystal-clear as they can be. Make extra sure the tasks that junior devs work on won't take them too far off the beaten path. Try to add comments/more notes to these tasks: where to start, a very rough sketch of the solution, how to test: anything can help.</li>
</ul>
<p>Only one of the three junior developers we hired was slightly familiar with monad transformers at the time they were hired. The other two were familiar with monads. We were able to get all three to contribute PRs in less than a week after they started. Within 3 to 6 months, I noticed they started being able to complete tasks with little supervision. One of them has been with us for little over an year, and they are now able to take on complicated tasks (major refactoring, learning new concepts, etc.) pretty much on their own.</p>
<h2 id="you-cant-possibly-teach-a-junior-x-in-y-days">You can't possibly teach a junior X in Y days</h2>
<p>Since the subject is hot, I just saw a <a href="https://twitter.com/jkachmar/status/1210977393197883393">tweet from Joe Kachmar</a> which expresses the very idea I want to combat: these things aren't THAT hard to teach. Of course a junior won't be able to invent a new type of lenses, add a new layer to our application's monad stack, or re-invent <code>generic-lens</code>, but nobody's expecting them to.</p>
<p>After a week of training, I am sure a junior developer can add a new REST API endpoint that is similar to one that's already in our application. They can use getter lenses similar to the ones we already have, but targeting different fields: they can re-use the existing infrastructure to write "boring" code using whatever level of fancy Haskell is already there as a guide.</p>
<p>And sure, sometimes they'll try something new and they'll get stuck on a 20-page GHC type error. That's when they ask for help, because they know it's okay not knowing things, and there's always someone available that's happy to help (and they won't help by fixing the error for them, but by guiding them into understanding and fixing the problem themselves).</p>
<h2 id="why-not-both">Why not both?</h2>
<p>It's hard to focus on multiple solutions to the same problem. I am also worried that the "Boring Haskell Manifesto" can even be harmful in the long run.</p>
<p>Writing programs is really, really hard. Nothing focuses this feeling better than writing pure FP, because it forces you to be clear, precise and thorough about everything: you can't ignore <code>Nothing</code>s, you can't discard <code>Left</code>s implicitly, you don't get to shove things into a mutable global state.</p>
<p>Writing programs is really, really hard for everyone. It's not only hard for junior developers. It's also hard for senior developers. We haven't figured this out, we're not even close. We still have a terrible story for errors: their composability is far from ideal. We still have a lot of competing libraries for effects, and more seem to be coming. There are a lot of libraries to be explored and discovered.</p>
<p>I do think that each team should be careful when adding language extensions and choosing libraries for each project they work on. And I do think the "fancyness" needs to be taken into account. As Parsons put it on slack</p>
<blockquote>
<p>fanciness of your code should be gated on the size of your mentoring/training budget if you value hiring juniors</p>
</blockquote>
<p>I totally agree, although I would also add that another important aspect worth considering is the benefit of said fancyness.</p>
<p>There are many reasons one might want to stray off the beaten path. Fancy type-level code might save you a ton of code duplication, or it might add features that would otherwise make the code brittle or hard to maintain. For some projects, this may be worth it.</p>
<p>I don't think a blessed set of libraries or extensions will help with this. Which streaming library gets to be picked? Will it be <code>conduit</code> over <code>pipes</code>? What about <code>streaming</code>?</p>
<p>As I said, I think it's the wrong thing to focus on.</p>
<h2 id="conclusion">Conclusion</h2>
<p>We need to stop over-appreciating how hard it is to use "fancy" libraries like <code>servant</code>, <code>lens</code> or <code>recursion-schemes</code>. Give junior developers a fighting chance and they will surprise you.</p>
<p>I don't think there's anything that makes our company's junior developer success story non-reproducible anywhere else. Our local university doesn't focus on FP or Haskell (they do have one course where they teach Haskell, but that's pretty much it). We were actually forced to take this route because there's no other companies that do Haskell locally (as far as I know), so we can't just find Haskell developers around.</p>
<p>I think this is reproducible anywhere, on pretty much any codebase. We just need to open up junior positions, and give them the support they need to succeed. Have you had some different experience? Is it hard to find junior developers that are somewhat familiar with monads?</p>
<p>Go out there, convince your team that they're not actually living in an ivory tower. It's not that hard, and we're not special for understanding how to use these language extensions and libraries. We can teach junior developers how to use them.</p>]]></content>
  </entry>
  <entry>
      <title>The Functor Family: Bifunctor</title>
      <link href="https://cvlad.infoposts/2020-01-02-bifunctor.html"/>
      <id>https://cvlad.infoposts/2020-01-02-bifunctor.html</id>
      <updated>2020-01-02T00:00:SZ</updated>
      <category term="haskell"/>
      <category term="functor"/>
      <summary>A look into bifunctors.</summary>
      <content type="html"><![CDATA[<p>This post assumes prior knowledge of - the <code>Functor</code> class / concept - the functor instance for <code>Either a</code>, <code>(,) a</code> - basic kind knowledge, e.g. the difference between <code>* -&gt; *</code> and <code>* -&gt; * -&gt; *</code></p>
<h2 id="why">Why</h2>
<p>In Haskell, functors can only be defined for types of kind <code>* -&gt; *</code> like <code>Maybe a</code> or <code>[a]</code>. Their instances allow us to use <code>fmap</code> (or <code>&lt;$&gt;</code>) to go from <code>Maybe a</code> to <code>Maybe b</code> using some <code>a -&gt; b</code>, like:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> <span class="fu">show</span> <span class="op">&lt;$&gt;</span> <span class="dt">Just</span> <span class="dv">1</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Just</span> <span class="st">&quot;1&quot;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> <span class="fu">show</span> <span class="op">&lt;$&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="dt">Nothing</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> <span class="fu">show</span> <span class="op">&lt;$&gt;</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>[<span class="st">&quot;1&quot;</span>, <span class="st">&quot;2&quot;</span>, <span class="st">&quot;3&quot;</span>]</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> <span class="fu">show</span> <span class="op">&lt;$&gt;</span> []</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>[]</span></code></pre></div>
<p>We can even define functor instances for higher kinded types, as long as we fix type arguments until we get to <code>* -&gt; *</code>. For example, <code>Either</code> has kind <code>* -&gt; * -&gt; *</code>, but <code>Either e</code> has kind <code>* -&gt; *</code>. So that means that we can have a functor instance for <code>Either e</code>, given some type <code>e</code>. This might sound confusing at first, but all it means is that the <code>e</code> cannot vary, so we can go from <code>Either e a</code> to <code>Either e b</code> using some <code>a -&gt; b</code>, but we cannot go from <code>Either e1 a</code> to <code>Either e2 a</code> or <code>Either e2 b</code> even if we had both <code>a -&gt; b</code> and <code>e1 -&gt; e2</code>. How would we even pass two functions to <code>fmap</code>?</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> <span class="fu">show</span> <span class="op">&lt;$&gt;</span> <span class="dt">Right</span> <span class="dv">1</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Right</span> <span class="st">&quot;1&quot;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> <span class="fu">show</span> <span class="op">&lt;$&gt;</span> <span class="dt">Left</span> <span class="dt">True</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="dt">Left</span> <span class="dt">True</span></span></code></pre></div>
<p>In the first example, we go from <code>Either a Int</code> to <code>Either a String</code> using <code>show :: Int -&gt; String</code>. In the second example, we go from <code>Either Bool a</code> to <code>Either Bool String</code>, where <code>a</code> needs to have a <code>Show</code> instance.</p>
<p>But what if we want to go from <code>Either a x</code> to <code>Either b x</code>, given some <code>a -&gt; b</code>?</p>
<p>Let's see how we could implement it ourselves:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mapLeft ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Either</span> a x <span class="ot">-&gt;</span> <span class="dt">Either</span> b x</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>mapLeft f (<span class="dt">Left</span> a) <span class="ot">=</span> <span class="dt">Left</span> (f a)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>mapLeft _ r        <span class="ot">=</span> r</span></code></pre></div>
<p>Since we are trying to map the <code>Left</code>, the interesting bit is for that constructor: we apply <code>f</code> under <code>Left</code>. Otherwise, we just leave the value as-is; a <code>Right</code> value of type <code>x</code> (we could have written <code>mapLeft _ (Right x) = Right x</code> and it would work the same).</p>
<p>Here's a few warm-up exercises. The first uses typed holes to guide you and clarify what's meant by "using <code>either</code>". The last exercise can be a bit tricky. Look up what <code>Const</code> is and use typed holes.</p>
<p><em>Exercise 1</em>: re-implement <code>mapLeft'</code> using <code>either</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mapLeft&#39; ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Either</span> a x <span class="ot">-&gt;</span> <span class="dt">Either</span> b x</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>mapLeft&#39; f e <span class="ot">=</span> <span class="fu">either</span> _leftCase _rightCase e</span></code></pre></div>
<p><em>Exercise 2</em>: implement <code>mapFirst</code>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mapFirst ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a, x) <span class="ot">-&gt;</span> (b, x)</span></code></pre></div>
<p><em>Exercise 3</em>: implement <code>remapConst</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Functor.Const</span> (<span class="dt">Const</span>(..))</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="ot">remapConst ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Const</span> a x <span class="ot">-&gt;</span> <span class="dt">Const</span> b x</span></code></pre></div>
<h2 id="how">How</h2>
<p>While we can implement <code>mapLeft</code>, <code>mapFirst</code>, and <code>remapConst</code> manually, there is a pattern: some types of kind <code>* -&gt; * -&gt; *</code> allow both their type arguments to be mapped like a <code>Functor</code>, so we can define a new class:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Bifunctor</span> p <span class="kw">where</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">{-# MINIMAL bimap | first, second #-}</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  bimap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> p a c <span class="ot">-&gt;</span> p b d</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  first ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> p a c <span class="ot">-&gt;</span> p b c</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="ot">  second ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> p a b <span class="ot">-&gt;</span> p a c</span></code></pre></div>
<p><code>bimap</code> takes two functions and is able to map both arguments in a type of kind <code>* -&gt; * -&gt; *</code>. <code>first</code> is a lot like the functions we just defined manually. <code>second</code> is always the same thing as <code>fmap</code>. This class exists in <code>base</code>, under <code>Data.Bifunctor</code>.</p>
<p><em>Exercise 4</em>: implement <code>bimap</code> in terms of <code>first</code> and <code>second</code>.</p>
<p><em>Exercise 5</em>: implement <code>first</code> and <code>second</code> in terms of <code>bimap</code>.</p>
<p><em>Exercise 6</em>: implement the <code>Bifunctor</code> instance for <code>Either</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Bifunctor</span> <span class="dt">Either</span> <span class="kw">where</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  bimap f _ (<span class="dt">Left</span> a)  <span class="ot">=</span> _leftCase</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  bimap _ g (<span class="dt">Right</span> b) <span class="ot">=</span> _rightCase</span></code></pre></div>
<p><em>Exercise 7</em>: Implement the <code>Bifunctor</code> instance for tuples <code>(a, b)</code>.</p>
<p><em>Exercise 8</em>: Implement the <code>Bifunctor</code> instance for <code>Const</code>.</p>
<p><em>Exercise 9</em>: Implement the <code>Bifunctor</code> instance for <code>(a, b, c)</code>.</p>
<p><em>Exercise 10</em>: Find an example of a type with kind <code>* -&gt; * -&gt; *</code> that cannot have a <code>Bifunctor</code> instance.</p>
<p><em>Exercise 11</em>: Find an example of a type with kind <code>* -&gt; * -&gt; *</code> which has a <code>Functor</code> instance when you fix one type argument, but can't have a <code>Bifunctor</code> instance.</p>]]></content>
  </entry>
  <entry>
      <title>The Functor Family: Contravariant</title>
      <link href="https://cvlad.infoposts/2020-01-07-contravariant.html"/>
      <id>https://cvlad.infoposts/2020-01-07-contravariant.html</id>
      <updated>2020-01-07T00:00:SZ</updated>
      <category term="haskell"/>
      <category term="functor"/>
      <summary>A look into contravariant functors.</summary>
      <content type="html"><![CDATA[<p>This post assumes prior knowledge of - the <code>Functor</code> class / concept - the functor instance for <code>(-&gt;) r</code></p>
<h2 id="why">Why</h2>
<p>Not all higher kinded types <code>* -&gt; *</code> can have a <code>Functor</code> instance. While types like <code>Maybe a</code>, <code>(x, a)</code>, <code>r -&gt; a</code>, <code>Either e a</code> and <code>[a]</code> are <code>Functors</code> in <code>a</code>, there are some types that cannot have a <code>Functor</code> instance. A good example is <code>Predicate</code>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Predicate</span> a <span class="ot">=</span> <span class="dt">Predicate</span> {<span class="ot"> getPredicate ::</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span> }</span></code></pre></div>
<p>We call this type a predicate in <code>a</code> because, given some value of type <code>a</code> we can obtain a <code>True</code> or a <code>False</code>. So, for example: - <code>Predicate (&gt; 10)</code> is a predicate in <code>Int</code> which returns true if the number is greater than 10, - <code>Predicate (== "hello")</code> is a predicate in <code>String</code> which returns true if the string is equal to <em>"hello"</em>, and - <code>Predicate not</code> is a predicate in <code>Bool</code> which returns the negation of the boolean value it receives.</p>
<p>We can try writing a <code>Functor</code> instance and see what we can learn:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Predicate</span> <span class="kw">where</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Predicate</span> a <span class="ot">-&gt;</span> <span class="dt">Predicate</span> b</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> f (<span class="dt">Predicate</span> g) <span class="ot">=</span> </span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Predicate</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">$</span> \b <span class="ot">-&gt;</span> _welp</span></code></pre></div>
<p>As the type hole above would suggest, we need to return a <code>Bool</code> value, and we have: - <code>b :: b</code> - <code>f :: a -&gt; b</code> - <code>g :: a -&gt; Bool</code></p>
<p>There is no way we can combine these terms at all, let alone in such a way as to obtain a <code>Bool</code> value. The only way we would be able to obtain a <code>Bool</code> value is by calling <code>g</code>, but for that, we need an <code>a</code> -- but all we have is a <code>b</code>.</p>
<p>What if <code>f</code> was reversed, though? If we had <code>f' :: b -&gt; a</code>, then we could apply <code>b</code> to it <code>f' b :: a</code> and then pass it to <code>g</code> to get a <code>Bool</code>. Let's write this function outside of the <code>Functor</code> class:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mapPredicate ::</span> (b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Predicate</span> a <span class="ot">-&gt;</span> <span class="dt">Predicate</span> b</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>mapPredicate f (<span class="dt">Predicate</span> g) <span class="ot">=</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Predicate</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">$</span> \b <span class="ot">-&gt;</span> g (f b)</span></code></pre></div>
<p>This looks very weird, compared to <code>Functor</code>s, right? If you want to go from <code>Predicate a</code> to <code>Predicate b</code>, you need a <code>b -&gt; a</code> function?</p>
<p><em>Exercise 1</em>: fill in the typed hole <code>_e1</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">greaterThan10 ::</span> <span class="dt">Predicate</span> <span class="dt">Int</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>greaterThan10 <span class="ot">=</span> <span class="dt">Predicate</span> (<span class="op">&gt;</span> <span class="dv">10</span>)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="ot">exercise1 ::</span> <span class="dt">Predicate</span> <span class="dt">String</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>exercise1 <span class="ot">=</span> mapPredicate _e1 greaterThan10</span></code></pre></div>
<p><em>Exercise 2</em>: write <code>mapShowable</code> for the following type:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Showable</span> a <span class="ot">=</span> <span class="dt">Showable</span> {<span class="ot"> getShowable ::</span> a <span class="ot">-&gt;</span> <span class="dt">String</span> }</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="ot">mapShowable ::</span> (b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Showable</span> a <span class="ot">-&gt;</span> <span class="dt">Showable</span> b</span></code></pre></div>
<p><em>Exercise 3</em>: Use <code>mapShowable</code> and <code>showableInt</code> to implement <code>exercise3</code> such that <code>getShowable exercise3 True</code> is <code>"1"</code> and <code>getShowable exercise3 False</code> is <code>"2"</code>.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">showableInt ::</span> <span class="dt">Showable</span> <span class="dt">Int</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>showableInt <span class="ot">=</span> <span class="dt">Showable</span> <span class="fu">show</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="ot">exercise3 ::</span> <span class="dt">Showable</span> <span class="dt">Bool</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>exercise3 <span class="ot">=</span></span></code></pre></div>
<h2 id="how">How</h2>
<p><code>Predicate</code> and <code>Showable</code> are very similar, and types like them admit a <code>Contravariant</code> instance. Let's start by looking at it:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Contravariant</span> f <span class="kw">where</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  contramap ::</span> (b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span></code></pre></div>
<p>The instances for <code>Predicate</code> and <code>Showable</code> are trivial: they are exactly <code>mapPredicate</code> and <code>mapShowable</code>. The difference between <code>Functor</code> and <code>Contravariant</code> is exactly the function they receive: one is "forward" and the other is "backward", and it's all about how the data type is defined.</p>
<p>All <code>Functor</code> types have their type parameter <code>a</code> in what we call a <em>positive</em> position. This usually means there can be some <code>a</code> available in the type (which is always the case for tuples, or sometimes the case for <code>Maybe</code>, <code>Either</code> or <code>[]</code>). It can also mean <em>we can obtain an <code>a</code></em>, like is the case for <code>r -&gt; a</code>. Sure, we need some <code>r</code> to do that, but we are able to obtain an <code>a</code> afterwards.</p>
<p>On the opposite side, <code>Contravariant</code> types have their type parameter <code>a</code> in what we call a <em>negative</em> position: they <em>need</em> to consume an <code>a</code> in order to produce something else (a <code>Bool</code> or a <code>String</code> for our examples).</p>
<p><em>Exercise 4</em>: Look at the following types and decide which can have a <code>Functor</code> instance and which can have a <code>Contravariant</code> instance. Write the instances down:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">T0</span> a <span class="ot">=</span> <span class="dt">T0</span> a <span class="dt">Int</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">T1</span> a <span class="ot">=</span> <span class="dt">T1</span> (a <span class="ot">-&gt;</span> <span class="dt">Int</span>)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">T2</span> a <span class="ot">=</span> <span class="dt">T2L</span> a <span class="op">|</span> <span class="dt">T2R</span> <span class="dt">Int</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">T3</span> a <span class="ot">=</span> <span class="dt">T3</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">T4</span> a <span class="ot">=</span> <span class="dt">T4L</span> a <span class="op">|</span> <span class="dt">T4R</span> a</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">T5</span> a <span class="ot">=</span> <span class="dt">T5L</span> (a <span class="ot">-&gt;</span> <span class="dt">Int</span>) <span class="op">|</span> <span class="dt">T5R</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</span></code></pre></div>
<p>As with <code>Functor</code>s, we can partially apply higher kinded types to write a <code>Contravariant</code> instance. The most common case is for the flipped version of <code>-&gt;</code>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Op</span> a b <span class="ot">=</span> <span class="dt">Op</span> {<span class="ot"> getOp ::</span> b <span class="ot">-&gt;</span> a }</span></code></pre></div>
<p>While <code>a -&gt; b</code> has a <code>Functor</code> instance, because the type is actually <code>(-&gt;) a b</code>, and <code>b</code> is in a <em>positive</em> position, its flipped version has a <code>Contravariant</code> instance.</p>
<p><em>Exercise 5</em>: Write the <code>Contravariant</code> instance for <code>Op</code>:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Contravariant</span> (<span class="dt">Op</span> r) <span class="kw">where</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  contramap ::</span> (b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Op</span> r a <span class="ot">-&gt;</span> <span class="dt">Op</span> r b</span></code></pre></div>
<p><em>Exercise 6</em>: Write a <code>Contravariant</code> instance for <code>Comparison</code>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Comparison</span> a <span class="ot">=</span> <span class="dt">Comparison</span> {<span class="ot"> getComparison ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Ordering</span> }</span></code></pre></div>
<p><em>Exercise 7</em>: Can you think of a type that has both <code>Functor</code> and <code>Contravariant</code> instances?</p>
<p><em>Exercise 8</em>: Can you think of a type that can't have a <code>Functor</code> nor a <code>Contravariant</code> instance? These types are called <code>Invariant</code> functors.</p>]]></content>
  </entry>
  <entry>
      <title>The Functor Family: Profunctor</title>
      <link href="https://cvlad.infoposts/2020-01-22-profunctor.html"/>
      <id>https://cvlad.infoposts/2020-01-22-profunctor.html</id>
      <updated>2020-01-22T00:00:SZ</updated>
      <category term="haskell"/>
      <category term="functor"/>
      <summary>A look into profunctors</summary>
      <content type="html"><![CDATA[<p>This post assumes prior knowledge of - <a href="/contravariant">Contravariant</a> - <a href="/bifunctor">Bifunctor</a></p>
<h2 id="why">Why</h2>
<p>We've seen how types of kind <code>* -&gt; *</code> can have instances for <code>Functor</code> or <code>Contravariant</code>, depending on the position of the type argument. We have also seen that types of kind <code>* -&gt; * -&gt; *</code> can have <code>Bifunctor</code> instances. These types are morally <code>Functor</code> in both type arguments. We're left with one very common type which we can't map both arguments of: <code>a -&gt; b</code>. It does have a <code>Functor</code> instance for <code>b</code>, but the <code>a</code> is morally <code>Contravariant</code> (so it can't have a <code>Bifunctor</code> instance). This is where <code>Profunctor</code>s come in.</p>
<p>Here's a list of a few common types with the instances they allow:</p>
<table>
<thead>
<tr class="header">
<th>Type</th>
<th style="text-align: center;"><code>Functor</code></th>
<th style="text-align: center;"><code>Bifunctor</code></th>
<th style="text-align: center;"><code>Contravariant</code></th>
<th style="text-align: center;"><code>Profunctor</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>Maybe a</code></td>
<td style="text-align: center;">✓</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>[a]</code></td>
<td style="text-align: center;">✓</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>Either a b</code></td>
<td style="text-align: center;">✓</td>
<td style="text-align: center;">✓</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>(a,b)</code></td>
<td style="text-align: center;">✓</td>
<td style="text-align: center;">✓</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>Const a b</code></td>
<td style="text-align: center;">✓</td>
<td style="text-align: center;">✓</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><code>Predicate a</code></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">✓</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><code>a -&gt; b</code></td>
<td style="text-align: center;">✓</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">✓</td>
</tr>
</tbody>
</table>
<p>Although there are some exceptions, you will usually see <code>Contravariant</code> or <code>Profunctor</code> instances over function types. <code>Predicate</code> itself is a newtype over <code>a -&gt; Bool</code>, and so are most types with these instances.</p>
<p>Let's take a closer look at <code>a -&gt; b</code>. We can easily map over the <code>b</code>, but what about the <code>a</code>? For example, given <code>showInt :: Int -&gt; String</code>, what do we need to convert this function to <code>showBool :: Bool -&gt; String</code>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">showInt</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">showInt</span> <span class="ot">=</span> <span class="fu">show</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="ot">showBool ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>showBool b <span class="ot">=</span> _help</span></code></pre></div>
<p>We would have access to: - <code>showInt :: Int -&gt; String</code> - <code>b :: Bool</code> and we want to use <code>showInt</code>, so we would need a way to pass <code>b</code> to it, which means we'd need a function <code>f :: Bool -&gt; Int</code> and then <code>_help</code> would become <code>showInt (f b)</code>.</p>
<p>But if we take a step back, in order to go from <code>Int -&gt; String</code> to <code>Bool -&gt; String</code>, we need <code>Bool -&gt; Int</code>, which is exactly the <code>Contravariant</code> way of mapping types.</p>
<p><em>Exercise 1</em>: Implement a <code>mapInput</code> function like:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mapInput ::</span> (input <span class="ot">-&gt;</span> out) <span class="ot">-&gt;</span> (newInput <span class="ot">-&gt;</span> input) <span class="ot">-&gt;</span> (newInput <span class="ot">-&gt;</span> out)</span></code></pre></div>
<p>Extra credit: try a pointfree implementation as <code>mapInput = _</code>.</p>
<p><em>Exercise 2</em>: Try to guess how the <code>Profunctor</code> class looks like. Look at <code>Functor</code>, <code>Contravariant</code>, and <code>Bifunctor</code> for inspiration.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Profunctor</span> p <span class="kw">where</span></span></code></pre></div>
<p><em>Exercise 3</em>: Implement an instance for <code>-&gt;</code> for your <code>Profunctor</code> class.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Profunctor</span> (<span class="ot">-&gt;</span>) <span class="kw">where</span></span></code></pre></div>
<h2 id="how">How</h2>
<p>Unlike <code>Functor</code>, <code>Contravariant</code>, and <code>Bifunctor</code>, the <code>Profunctor</code> class is not in <code>base</code>/<code>Prelude</code>. You will need to bring in a package like <code>profunctors</code> to access it.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Profunctor</span> p <span class="kw">where</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">{-# MINIMAL dimap | lmap, rmap #-}</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  dimap ::</span> (c <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> p a b <span class="ot">-&gt;</span> p c d</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  lmap ::</span> (c <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> p a b <span class="ot">-&gt;</span> p c b</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="ot">  rmap ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> p a b <span class="ot">-&gt;</span> p a c</span></code></pre></div>
<p><code>dimap</code> takes two functions and is able to map both arguments in a type of kind <code>* -&gt; * -&gt; *</code>. <code>lmap</code> is like <code>mapInput</code>. <code>second</code> is always the same thing as <code>fmap</code>.</p>
<p><em>Exercise 4</em>: implement <code>dimap</code> in terms of <code>lmap</code> and <code>rmap</code>.</p>
<p><em>Exercise 5</em>: implement <code>lmap</code> and <code>rmap</code> in terms of <code>dimap</code>.</p>
<p><em>Exercise 6</em>: implement the <code>Profunctor</code> instance for <code>-&gt;</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Profunctor</span> (<span class="ot">-&gt;</span>) <span class="kw">where</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- your pick: dimap or lmap and rmap</span></span></code></pre></div>
<p><em>Exercise 7</em>: (hard) implement the <code>Profunctor</code> instance for:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Sum</span> f g a b</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="dt">L</span> (f a b)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">R</span> (g a b)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Profunctor</span> f, <span class="dt">Profunctor</span> g) <span class="ot">=&gt;</span> <span class="dt">Profunctor</span> (<span class="dt">Sum</span> f g) <span class="kw">where</span></span></code></pre></div>
<p><em>Exercise 8</em>: (hard) implement the <code>Profunctor</code> instance for:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Product</span> f g a b <span class="ot">=</span> <span class="dt">Product</span> (f a b, g a b)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Profunctor</span> f, <span class="dt">Profunctor</span> g) <span class="ot">=&gt;</span> <span class="dt">Profunctor</span> (<span class="dt">Product</span> f g) <span class="kw">where</span></span></code></pre></div>]]></content>
  </entry>
</feed>
