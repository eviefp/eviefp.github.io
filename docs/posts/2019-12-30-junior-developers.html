<!DOCTYPE html>
<html lang="en">
<head profile="http://www.w3.org/2005/10/profile">
    <meta charset="UTF-8">
    <meta name="description" content="Vladimir Ciobanu&#39;s Blog">
    <meta name="author" content="Vladimir Ciobanu">
    <meta name=viewport content="width=device-width, initial-scale=1">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@cvlad">
<meta name="twitter:creator" content="@cvlad">
<meta name="twitter:title" content="Hire and Train Haskell Junior Developers">
    <meta name="twitter:description" content="A plea to senior developers and team leads">
        <title>Hire and Train Haskell Junior Developers</title>
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/syntax.css">
</head>
<body>
    <header>
        <nav>
            <a id="beacon" href="/">
                <div id="home-text"> HOME </div>
            </a>
        </nav>
    
        <div class="right-sidebar">
            <a class="ext-link" href="https://twitch.tv/cvladfp">
            <img src="/images/twitch-logo.png" alt="Twitch Channel"/>
        </a>

            <a class="ext-link" href="https://youtube.com/channel/UCDvH0v4GelMrYleTKyFBbvQ">
            <img src="/images/youtube-logo.png" alt="Youtube Channel"/>
        </a>

            <a class="ext-link" href="https://github.com/vladciobanu">
            <img src="/images/github-logo.png" alt="Github Profile"/>
        </a>

            <a class="ext-link" href="https://twitter.com/cvlad">
            <img src="/images/twitter-logo.png" alt="Twitter Profile"/>
        </a>
    <div id="theme-button">DAY</div>
        </div>
    </header>

<div id="page">
    <div class="wrapper">
        <div class="masthead">
            <span class="title">
                Hire and Train Haskell Junior Developers
            </span>
            <br>

            <br>
            <span class="byline">by Vladimir Ciobanu</span>
            <br>
            <span class="date">Dec 30, 2019</span>
            <br>
            <div class="metadata">
            </div>
            <div class="tags">
              <span class="tag personal">personal</span>
              <span class="tag fp">fp</span>
              <span class="tag haskell">haskell</span>
            </div>
        </div>
    </div>
    <article class="post">
        <h2 id="tldr">TL;DR</h2>
<p>I think the reason we don't have more people doing Haskell is we're not actually hiring junior developers, and when we do, we don't set them up for success by properly training them.</p>
<h2 id="introduction">Introduction</h2>
<p>This post was sparked by a few other posts in the Haskell world. They are, to my knowledge, in chronological order: - Michal Snoyman's <a href="https://www.snoyman.com/blog/2019/11/boring-haskell-manifesto">Boring Haskell Manifesto</a> - Matt Parsons' <a href="https://www.parsonsmatt.org/2019/12/26/write_junior_code.html">Write Junior Code</a> - Marco Sampellegrini's <a href="https://alpacaaa.net/thoughts-on-haskell-2020/">My thoughts on Haskell in 2020</a></p>
<p>Snoyman's manifesto is a call to define a safe subset of the Haskell language and common libraries, provide documentation, tutorials, cookbooks, and continuously evolve, update, and help engineers use and get "boring Haskell" adopted.</p>
<p>Parsons notes that Haskell has a hiring problem: there are few jobs, and most of those are for senior developers. The reason for this is that we over-indulge in fancy Haskell, making our code needlessly complicated. If we wrote simple, junior-level Haskell, we would be able to hire junior developers and have them be productive.</p>
<p>Sampellegrini's post points out a few key problems: - there's a lot of extensions we need to keep track of, which makes things hard - if an idea looks good on paper, it doesn't mean it's going to be easy to maintain in the long run - inclusivity might be a problem: "I don't want a PhD to be a requirement to work with Haskell" - they argue there's marginal benefit to fancy types/Haskell</p>
<p>While I understand where all of these feelings are coming from, and I agree to some of the ideas, I think they have their marks on the wrong problem.</p>
<h2 id="the-real-problem">The Real Problem</h2>
<p>I think the real problem is that we are not putting up jobs for junior devs. We're not even giving them a chance. And when we are, we usually don't give them enough support (through training and making sure they know who to ask, and that it's okay to do so) to succeed.</p>
<p>I'm really not sure why we're not hiring more junior developers. It might be because seniors like to think that the code they are writing is so complicated that a junior would take too long to be able to understand, so they advise management that a junior cannot possibly be productive. Maybe it's because they don't want to be bothered with training junior devs, and they would rather just work on code instead? Or maybe it's because management doesn't like seniors' time being "wasted" on teaching junior devs?</p>
<p>Whatever the reason, I don't really think writing simpler code will help much. If the on-boarding process is lacking, if the company culture is not welcoming to junior devs, most of them will be set for failure from the get-go, regardless of how fancy or simple the code is.</p>
<h2 id="junior-developers">Junior Developers</h2>
<p>What is a junior developer? For the purposes of this article, I will define a Haskell junior developer as somebody who's able to confidently use simple monads like <code>Maybe</code>, <code>Either e</code>, <code>IO</code>, and the list monad. Ideally, they would also have a crude understanding of monad transformers (but not necessarily <code>mtl</code> as well). They are able to compose functions, reason about ADTs, and, perhaps most importantly, are motivated to learn more about Haskell and FP.</p>
<p>I currently work on two projects, both in Haskell. One of these projects has two junior Haskell developers, and the other has one. I will briefly go over the details of these projects as well as my mentoring experience in order to establish a baseline.</p>
<p>I have not been working with Haskell for very long. I actually come from OOP-land (you can <a href="https://cvlad.info/haskell/">read my story here</a>), and I have a lot of experience as a team lead. I have hired, trained, and mentored a decent number of junior devs, most of them in my OOP days, but also three of them recently, at the place I currently work. For the past year and a half, I have been the main developer in charge of training and making sure the junior devs are productive.</p>
<p>Our codebases (you can <a href="https://github.com/kframework/kore">see one of them here</a>) are pretty complicated: besides the fact that they use notoriously complex Haskell libraries such as <code>lens</code>, <code>servant</code>, and <code>recursion-schemes</code>, the domain problem is pretty complicated as well: we're essentially building an automated prover for a rewrite-based executable semantic framework (the other project is a pretty standard servant app, so not too much to go over there, although it does use <code>lens</code>, <code>generic-lens</code>, <code>persistent</code>/<code>esqueleto</code> and obviously <code>servant</code>).</p>
<p>This prelude was needed because I can't really speak about junior developers in general, but I can tell you about my experience with on-boarding junior Haskell developers on our projects. However, before that, I would like to add that the junior devs we hired were all either senior year at the local university, or fresh graduates. They were picked because they are all excited about FP, despite the fact that none of them had any previous professional experience related to FP or Haskell.</p>
<p>I am proud to say that all three junior devs are doing great. I obviously can't take any significant part of the credit (they are all very smart and hard working), but I think that there are a few things that contributed to their success: - <strong>Kindness</strong> we've all gone through this. We're all trying our best. Be kind and supportive. Praise them when they do a good job. Encourage them to come up with ideas and to bring their ideas forward. - <strong>Confidence</strong> make sure they know it's okay to not know things; there's a ton of things I don't know, and I make sure to be loud about it. I also make sure to show them how I find the answers to things I don't know. Of course, on top of literally telling them it's okay to ask questions and not know stuff, even if it feels like it's something they should know (there's no such thing, really: we all have our blind spots). - <strong>Support</strong> be there for them. We have daily meetings and we make sure we know what everybody's up to. We make sure to ask everybody if they're stuck or not, if they need help or more work. - <strong>Training</strong> at least until they get comfortable, make sure you go over the things that are "fancy" in the codebase. At the very least, make sure you go over a few examples and show them how it works. Make sure they understand. A few exercises where you work together can be particularly useful as well. - <strong>Clarity</strong> it is vitally important that tasks are as crystal-clear as they can be. Make extra sure the tasks that junior devs work on won't take them too far off the beaten path. Try to add comments/more notes to these tasks: where to start, a very rough sketch of the solution, how to test: anything can help.</p>
<p>Only one of the three junior developers we hired was slightly familiar with monad transformers at the time they were hired. The other two were familiar with monads. We were able to get all three to contribute PRs in less than a week after they started. Within 3 to 6 months, I noticed they started being able to complete tasks with little supervision. One of them has been with us for little over an year, and they are now able to take on complicated tasks (major refactoring, learning new concepts, etc.) pretty much on their own.</p>
<h2 id="you-cant-possibly-teach-a-junior-x-in-y-days">You can't possibly teach a junior X in Y days</h2>
<p>Since the subject is hot, I just saw a <a href="https://twitter.com/jkachmar/status/1210977393197883393">tweet from Joe Kachmar</a> which expresses the very idea I want to combat: these things aren't THAT hard to teach. Of course a junior won't be able to invent a new type of lenses, add a new layer to our application's monad stack, or re-invent <code>generic-lens</code>, but nobody's expecting them to.</p>
<p>After a week of training, I am sure a junior developer can add a new REST API endpoint that is similar to one that's already in our application. They can use getter lenses similar to the ones we already have, but targeting different fields: they can re-use the existing infrastructure to write "boring" code using whatever level of fancy Haskell is already there as a guide.</p>
<p>And sure, sometimes they'll try something new and they'll get stuck on a 20-page GHC type error. That's when they ask for help, because they know it's okay not knowing things, and there's always someone available that's happy to help (and they won't help by fixing the error for them, but by guiding them into understanding and fixing the problem themselves).</p>
<h2 id="why-not-both">Why not both?</h2>
<p>It's hard to focus on multiple solutions to the same problem. I am also worried that the "Boring Haskell Manifesto" can even be harmful in the long run.</p>
<p>Writing programs is really, really hard. Nothing focuses this feeling better than writing pure FP, because it forces you to be clear, precise and thorough about everything: you can't ignore <code>Nothing</code>s, you can't discard <code>Left</code>s implicitly, you don't get to shove things into a mutable global state.</p>
<p>Writing programs is really, really hard for everyone. It's not only hard for junior developers. It's also hard for senior developers. We haven't figured this out, we're not even close. We still have a terrible story for errors: their composability is far from ideal. We still have a lot of competing libraries for effects, and more seem to be coming. There are a lot of libraries to be explored and discovered.</p>
<p>I do think that each team should be careful when adding language extensions and choosing libraries for each project they work on. And I do think the "fancyness" needs to be taken into account. As Parsons put it on slack</p>
<blockquote>
<p>fanciness of your code should be gated on the size of your mentoring/training budget if you value hiring juniors</p>
</blockquote>
<p>I totally agree, although I would also add that another important aspect worth considering is the benefit of said fancyness.</p>
<p>There are many reasons one might want to stray off the beaten path. Fancy type-level code might save you a ton of code duplication, or it might add features that would otherwise make the code brittle or hard to maintain. For some projects, this may be worth it.</p>
<p>I don't think a blessed set of libraries or extensions will help with this. Which streaming library gets to be picked? Will it be <code>conduit</code> over <code>pipes</code>? What about <code>streaming</code>?</p>
<p>As I said, I think it's the wrong thing to focus on.</p>
<h2 id="conclusion">Conclusion</h2>
<p>We need to stop over-appreciating how hard it is to use "fancy" libraries like <code>servant</code>, <code>lens</code> or <code>recursion-schemes</code>. Give junior developers a fighting chance and they will surprise you.</p>
<p>I don't think there's anything that makes our company's junior developer success story non-reproducible anywhere else. Our local university doesn't focus on FP or Haskell (they do have one course where they teach Haskell, but that's pretty much it). We were actually forced to take this route because there's no other companies that do Haskell locally (as far as I know), so we can't just find Haskell developers around.</p>
<p>I think this is reproducible anywhere, on pretty much any codebase. We just need to open up junior positions, and give them the support they need to succeed. Have you had some different experience? Is it hard to find junior developers that are somewhat familiar with monads?</p>
<p>Go out there, convince your team that they're not actually living in an ivory tower. It's not that hard, and we're not special for understanding how to use these language extensions and libraries. We can teach junior developers how to use them.</p>

        <br>
        <br>

        <!--Share buttons-->
        <div class="social-buttons">
            <a href="https://twitter.com/share" class="twitter-share-button"
                                                data-url="https://cvlad.info" data-text="Check out: Hire and Train Haskell Junior Developers - " data-via="cvlad">Tweet</a>
            <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
            <a href="https://twitter.com/cvlad" class="twitter-follow-button" data-show-count="false" data-dnt="true">Follow @cvlad</a>
            <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
            <div class="fb-like" data-href="" data-layout="button" data-action="like" data-show-faces="true" data-share="true"></div>
        </div>
</article>

</div>

<footer>
    Built with Haskell using <a href="https://github.com/ChrisPenner/slick">slick</a> ❤️
</footer>

<link href='https://fonts.googleapis.com/css?family=Quicksand:300,400' rel='stylesheet' type='text/css'>
<link href='https://fonts.googleapis.com/css?family=Oswald' rel='stylesheet' type='text/css'>
<script src="/js/main.js"></script>
</body>
</html>
