---
title: "About Evie"
author: Evie Ciobanu
date: Mar 12, 2024
tags: []
description: "Things you may want to know about me and working with me."
image: evie.png
---

Hey, I'm Evie! Welcome to my about page. I generally use this to promote myself when I'm available
for my next gig.

In the paragraphs below, you'll find what my **core values** are in respect to leading teams.

You can also find my **work experience**, the technologies I've worked with, and some of the
responsibilities I've had during this time.

Lastly, I talk about my **technical interests**, which is basically the things that get me excited
about technology and computer science.

If you want to **contact** me, please use `hello@eevie.ro`.

## My core values

ðŸ‘‰ **Empathy**: I believe everyone wants to do their best. By being honest, kind, and understanding with
people, I can empower them to do their best and feel good about the work they do.

ðŸ‘‰ **Teamwork**: Better yet than individuals doing their best is a team that does its best. Holding
regular team activities and making sure the team is empowered to make decisions and have its
concerns heard is a great way to have teams that perform beter than the sum of their parts.

ðŸ‘‰ **Connection**: Thereâ€™s a lot of depth in both upper management decisions and the work engineering
teams perform on a daily basis. Itâ€™s very easy for these to become disconnected, and for members
of either groups become enstrangered. Itâ€™s the Engineering Managerâ€™s job to act as a liason and
ensure everybody is aligned and communicates openly and effectively.

ðŸ‘‰ **Mentorship**: Tech is very dear to my heart. And while I have no intention to veto any
technical decisions made by my team, I am there to ask the difficult questions, come up with
unique ideas and perspectives from my diverse experience, and help the team make the best decisions
they can.

ðŸ‘‰ **Diversity**: As a member of multiple marginalized groups, I am keenly aware of the
struggles that minorities face in tech. The teams I lead strive to be inclusive, kind and welcoming
to everyone. These teams see diversity as power, ability to gain a better perspective and
unique views on the problems we face.

## My Work Experience

I have been doing tech professionally for over 15 years.

I started my career with C# and Javascript/Typescript developing large-scale web applications and
web services. At the mid-point of my career, I decided to switch it up so I picked up Functional
Programming through Haskell, Purescript, and nix. I've been working with FP for over 6 years now.

I also have experience with compilers, theorem provers, GraphQL, Postgres, database access
proxies and libraries, a solid CS background and a keen interest in theoretical computer science
(type theory, lambda calculus, abstract algebra, etc.).

I have more than 7 years of experience in leading teams as either Team Lead or **Engineering Manager**.
During this time, I have've been responsible for

ðŸ—¨ï¸ **People**: Handle recruitment, hold 1on1s, make sure everyone is productive, happy, and heard.

ðŸ—¨ï¸ **Team**: Team exercises and activities, games, help individuals work and act as a team through
a strong sense of team ownership and camaraderie.

ðŸ—¨ï¸ **Process**: Hold retrospectives, find bottlenecks, resolve team dysfunctions, find creative and
team and company-specific ways to improve the way we work.

I have more than 8 years of doing individual contributions as a **Software Engineer**:

ðŸ’» **First Principles**: I rely on both a strong theoretical background and many years of personal
experiences to make informed decisions. I strongly believe in simplicity and clarity of code and
using the right tool for the job.

ðŸ’» **Learning**: I learned Haskell, PureScript, Nix, Scala, and Rust, as well as a lot of
advanced math topics. I am always learning new things and trying out new technologies.

> One fun and recent example is that I've used [Lean](https://lean-lang.org/) to solve (the vast
> majority of) the 2023 Advent of Code problems. Using a theorem prover/dependently typed
> programming language to work on coding puzzles was a great
> [learning experience](https://eevie.ro/posts/2023-12-21-lean-sigma.types.html).

ðŸ’» **Presentations**: Held multiple presentations at local FP user groups and the local University,
work presentations and workships, as well as a
[talk at Functional Conf](https://www.youtube.com/watch?v=wpV8WbpuAKY) about program testing and
software verification.

ðŸ’» **Community involvement**: I'm an active member in the FP community, currently holding a position on the
[Haskell Foundation board](https://haskell.foundation/who-we-are/).

ðŸ’» **CI/CD**: I'm a strong believer in reproducible builds, easy and predictable deployments, and
consistent developer local setup.

## My Technical Interests

I am really interested in (theoretical) computer science, functional programming languages, program
verification and reproducible builds and deployments.

I am often times using (theoretical) **computer science** when working on technical projects. Using
a common *mathematical* language that has the benefit of having *provable* and *testable* statements
can greatly improve technical *conversations*. I have successfully used theoretical methods to
*refactor*, *optimize*, and *clarify* both small and large areas of code. I am mostly interested
in **type theory**, **lambda calculus**, and **abstract algebra**.

**Functional programming** ties in very well with theoretical computer science, and it's generally
easier to translate FP to theory and back (it's possible for all paradigms, but FP is closest). I
mostly have experience with *Haskell* and *Purescript*, but a lot of languages can now be used in a
functional style or share a lot of features with functional programming languages (e.g. Elixir,
Scala, Kotlin, Clojure, Typescript, etc.).

Most programs have **critical paths** -- paths that can cause a company to lose a lot of money or even
fail of they contain bugs. A lot of companies rely on engineer dilligence and automated testing.
And while these are absolutely critical, there's one more kind of verification missing: we can
**formally prove** these critical paths are correct. One great example is Amazon's Cedar Policy
Language. It's an authorization policy language that has a Lean-based implementation,
proofs-included. This gives a different level of *security* and *guarantees* to critical paths.

I really like [**nix/NixOS**](https://nixos.org/). I use it for all my devices, which are highly
customized (you can check my github profile's [*dotfiles*](https://github.com/eviefp/dotfiles) for
details!). And while my personal use is fun and interesting, nix shines for **sharing**
development environments by *pinning* dependencies exactly and giving developers *confidence* that
their local build will be identical across devices, team members, CI/CD, and production.



Again, if you want to get in touch, please **email** me at `hello@eevie.ro`.
